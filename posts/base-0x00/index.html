<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Security Researcher in Reversing/Malware/Low Level fields">
    <meta name="Author" content="Midnight Reverser">
    <meta name="keywords" content="midnighthackings midnight-rev midnight">
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/syntax.css>
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>Midnight Hackings</title>
  </head><body><aside id="sidenav">
    <header>
    

    <a id="branding" href=https://blog.midnighthackings.com/>
        
            Midnight Hackings
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/posts"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>posts</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-ms"></i>
                <span>tags</span>
            </a>
        
            		
            <a href="https://github.com/midnight-rev"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-ms"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="/contact"
                
            >
                <i class="far fa-envelope"></i>
                <span>contact</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">
    
    <h1 id="title">Base 0x00 - Procedimento de linking &amp; seus tipos</h1>
    
      
    <nav id="TableOfContents">
  <ul>
    <li><a href="#executáveis">Executáveis</a></li>
    <li><a href="#tipos-de-linking">Tipos de linking</a>
      <ul>
        <li><a href="#static-linking">Static Linking</a></li>
        <li><a href="#dynamic-linking-load-time-dynamic-linking">Dynamic Linking (load-time Dynamic Linking)</a></li>
        <li><a href="#runtime-linking-run-time-dynamic-linking">Runtime Linking (run-time Dynamic Linking)</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <h1 id="introdução">Introdução</h1>
<p>Softwares são compostos, em sua maioria, por códigos próprios, escritos pelo programador daquele software, e por códigos de bibliotecas, feito por outros programadores. Bibliotecas podem ser entendidas como códigos já escritos, reusáveis, que fornecem implementações de funções a serem utilizadas por diversos outros programas. Por exemplo, uma biblioteca de matemática fornece funções que podem ser utilizadas por um programa simples de somar dois números, um software de calculadora ou até mesmo programas para auxiliar estudos científicos em áreas que dependem de precisão de várias casas decimais.</p>
<p>Nesse artigo, iremos entender os tipos de bibliotecas existentes e  como elas são incorporadas pelos programas que as utilizam. Vamos analisar a forma como os arquivos executáveis, em especial os <em>Portable Executable</em> (EXE) e <em>Executable and Linikable Format</em>, mantém referência às funções importadas de bibliotecas e explicar/implementar técnicas utilizadas por malwares para evadir detecção e a fase de análise estática simples realizada por analistas de malware.</p>
<h2 id="executáveis">Executáveis</h2>
<p>A geração de um executável passa pelos estágios de escrita de um código (geralmente em uma linguagem de alto nível portável, como C/C++) e a fase conhecida genericamente por &ldquo;compilação&rdquo;. Porém, a &ldquo;compilação&rdquo;, como é popularmente conhecida, consiste de diversas etapas, dentre elas a própria compilação - transformação de um código em alto nível em um source Assembly - montagem e linking. Na imagem abaixo estão representadas as fases genéricas da compilação de um arquivo.</p>
<p><img src="img/03762422f33b940c9ab2650e38caa65c.png" alt="03762422f33b940c9ab2650e38caa65c.png"></p>
<p>O primeiro passo é a compilação de um ou mais arquivos de código-fonte de uma linguagem de programação de alto nível para um fonte em assembly, representado pelo passo <em>Compilation (gcc -S)</em> na figura. Tomemos como exemplo o seguinte código <em>hello.c</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Hello World</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Ao executarmos <code>gcc -S hello.c</code>, obtemos a seguinte saída no arquivo gerado <em>hello.s</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="cl">        <span class="na">.file</span>   <span class="s">&#34;hello.c&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">.text</span>
</span></span><span class="line"><span class="cl">        <span class="na">.section</span>        <span class="no">.rodata</span>
</span></span><span class="line"><span class="cl"><span class="nl">.LC0:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.string</span> <span class="s">&#34;Hello World&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">.text</span>
</span></span><span class="line"><span class="cl">        <span class="na">.globl</span>  <span class="no">main</span>
</span></span><span class="line"><span class="cl">        <span class="na">.type</span>   <span class="no">main</span><span class="p">,</span> <span class="na">@function</span>
</span></span><span class="line"><span class="cl"><span class="nl">main:</span>
</span></span><span class="line"><span class="cl"><span class="nl">.LFB0:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_startproc</span>
</span></span><span class="line"><span class="cl">        <span class="nf">endbr64</span>
</span></span><span class="line"><span class="cl">        <span class="nf">pushq</span>   <span class="nv">%rbp</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_def_cfa_offset</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_offset</span> <span class="mi">6</span><span class="p">,</span> <span class="p">-</span><span class="mi">16</span>
</span></span><span class="line"><span class="cl">        <span class="nf">movq</span>    <span class="nv">%rsp</span><span class="p">,</span> <span class="nv">%rbp</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_def_cfa_register</span> <span class="mi">6</span>
</span></span><span class="line"><span class="cl">        <span class="nf">leaq</span>    <span class="no">.LC0</span><span class="p">(</span><span class="nv">%rip</span><span class="p">),</span> <span class="nv">%rax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">movq</span>    <span class="nv">%rax</span><span class="p">,</span> <span class="nv">%rdi</span>
</span></span><span class="line"><span class="cl">        <span class="nf">call</span>    <span class="no">puts@PLT</span>
</span></span><span class="line"><span class="cl">        <span class="nf">movl</span>    <span class="no">$0</span><span class="p">,</span> <span class="nv">%eax</span>
</span></span><span class="line"><span class="cl">        <span class="nf">popq</span>    <span class="nv">%rbp</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_def_cfa</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="nf">ret</span>
</span></span><span class="line"><span class="cl">        <span class="na">.cfi_endproc</span>
</span></span><span class="line"><span class="cl"><span class="nl">.LFE0:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.size</span>   <span class="no">main</span><span class="p">,</span> <span class="no">.-main</span>
</span></span><span class="line"><span class="cl">        <span class="na">.ident</span>  <span class="s">&#34;GCC: (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">.section</span>        <span class="no">.note.GNU-stack</span><span class="p">,</span><span class="s">&#34;&#34;</span><span class="p">,</span><span class="na">@progbits</span>
</span></span><span class="line"><span class="cl">        <span class="na">.section</span>        <span class="no">.note.gnu.property</span><span class="p">,</span><span class="s">&#34;a&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="na">.align</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">1</span><span class="no">f</span> <span class="p">-</span> <span class="mi">0</span><span class="no">f</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">4</span><span class="no">f</span> <span class="p">-</span> <span class="mi">1</span><span class="no">f</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">5</span>
</span></span><span class="line"><span class="cl"><span class="err">0:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.string</span> <span class="s">&#34;GNU&#34;</span>
</span></span><span class="line"><span class="cl"><span class="err">1:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.align</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">0xc0000002</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">3</span><span class="no">f</span> <span class="p">-</span> <span class="mi">2</span><span class="no">f</span>
</span></span><span class="line"><span class="cl"><span class="err">2:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.long</span>   <span class="mi">0x3</span>
</span></span><span class="line"><span class="cl"><span class="err">3:</span>
</span></span><span class="line"><span class="cl">        <span class="na">.align</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="err">4:</span>
</span></span></code></pre></div><p>Esse arquivo não é trivial e utiliza muitas muitas diretivas do <a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_3.html">GNU Assembler</a>, que não são necessariamente instruções. A main é indicada pela label <em>main</em> e em específico pela label local <em>.LFB0</em>. A string <em>Hello, World</em> é indicada pela label local <em>.LC0</em>, que é utilizada diretamente em <em>.LFB0</em>.</p>
<p>O arquivo descrito acima é processado internamente pela suite <em>gcc</em> para gerar o <em>arquivo-objeto</em>, algo que também pode ser realizado pelo GNU Assembler via <code>as hello.s -o hello.o</code>, conforme imagem abaixo. Ao analisar os metadados de <code>hello.o</code> com os softwares <em>file</em> e <em>readelf</em>, é possível perceber que um arquivo-objeto em Linux nada mais é que um arquivo ELF relocável (mais especificamente o tipo <strong>ET_REL</strong> no campo <em>ElfN_Ehdr-&gt;e_type</em> de um arquivo ELF).</p>
<p><img src="img/2e4bd02a99e19c136b20ea5ca7a0ec2c.png" alt="2e4bd02a99e19c136b20ea5ca7a0ec2c.png"></p>
<blockquote>
<p><strong>NOTA</strong>: esse passo também pode ser realizado diretamente pelo utilitário gcc, através do comando <code>gcc -c hello.c -o hello.o</code>. Através desse comando não é necessário compilar e montar diretamente o arquivo-fonte.</p>
</blockquote>
<p>Porém, se tentarmos executar o arquivo-objeto criado a partir da montagem, obtemos o seguinte erro:</p>
<p><img src="img/7787d49ff97ee4c562f2d517529813a2.png" alt="7787d49ff97ee4c562f2d517529813a2.png"></p>
<p>O leitor pode estar se perguntando: &ldquo;mas o arquivo-objeto montado já contém dados e código, por que não é possível executá-lo?&rdquo;. Para explicar melhor essa questão, vamos relembrar a saída do comando <em>file</em>:</p>
<blockquote>
<p>hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p>
</blockquote>
<p>O atributo relocável traz o significado de &ldquo;móvel&rdquo;. Um arquivo-objeto não está ligado a outros códigos-objeto e bibliotecas, eles se referem apenas àquela <a href="https://en.wikipedia.org/wiki/Translation_unit_(programming)">unidade de tradução</a>. Logo, ele não contém códigos externos àquela unidade de tradução (ou arquivo fonte + diretivas #include), não podendo rodar corretamente. Porém, isso permite que ele seja ligado a outros arquivos-objeto para montar um executável final - por isso o nome &ldquo;relocável&rdquo;.</p>
<p>Entretanto, não é possível executar o arquivo-objeto até mesmo de um código mínimo que não possui ligações externas. O motivo é que um arquivo-objeto, devido a ser relocável, não contém endereçamento virtual definido. Podemos checar isso realizando o disassembly da função mais com um software disassembler, como o <em>objdump</em>:</p>
<p><img src="img/a03c337a0a2025b2a1d277cee919d7a5.png" alt="a03c337a0a2025b2a1d277cee919d7a5.png"></p>
<p>Note que os endereços das instruções, destacados em vermelho, estão iniciando em endereços muito baixos, partindo do 0, além das referências apontarem para endereços que não fazem sentido. Esses valores são como <em>placeholders</em> para serem definidos corretamente na última fase: o Linking.</p>
<p>A etapa de linking irá unir os arquivos-objetos em um único executável, definindo o endereçamento virtual de cada seção, suas permissões e resolvendo as referências de endereços nas instruções. Isso é feito pelo software <em>ld</em>, chamado implicitamente pelo gcc quando o argumento <em>-c</em> não é passado. Na imagem abaixo é possível verificar que o arquivo final realmente é executável e as referências de endereços foram devidamente resolvidas.</p>
<p><img src="img/a4cf00eae1ea056e23b6970296312257.png" alt="a4cf00eae1ea056e23b6970296312257.png"></p>
<h2 id="tipos-de-linking">Tipos de linking</h2>
<p>Nas seções anteriores foi explicado o processo da geração de um executável. Entretanto, a fase de linking tem suas particularidades, em especial para a Segurança da Informação. Há três tipos de linking principais que mais encontramos nos programas para sistemas operacionais atuais: linking estático (<em>static linking</em>), linking dinâmico (<em>dynamic linking</em>) e linking em tempo de execução (<em>runtime linking</em>). Nas seções abaixo serão explanados os tipos de linking, suas características e como realizá-los em GNU/Linux e Windows.</p>
<p>Para todos os exemplos, a não ser que explicitamente falado, utilizaremos como base os seguintes arquivos-fonte:</p>
<p><strong>main.c</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;mymath.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">soma</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A soma eh %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>mymath.c</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;mymath.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">soma</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>mymath.h</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">soma</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span></code></pre></div><p>O objetivo é compilar essa solução com os diversos tipos de linking, que resultará em um executável (<em>main.c</em>) que chama o código disponível em <em>mymath.c</em>. <em>mymath.c</em> será a biblioteca utilizada para demonstrar os tipos de linking. Especificamente, será realizada uma chamada à função <em>soma(int, int)</em> que irá retornar a soma de dois inteiros.</p>
<h3 id="static-linking">Static Linking</h3>
<p>O linking estático ocorre quando o código de uma biblioteca tem suas funções e dados &ldquo;copiados&rdquo; para o executável final. A biblioteca é chamada de biblioteca estática (extensão <em>.a</em> em GNU/Linux e <em>.lib</em> em Windows) e ela será composta de uma série de arquivos-objeto que a implementam. De fato, em especial no Linux, a biblioteca é apenas um <em>archive</em>, ou um arquivo composto de diversos outros arquivos, criado pelo software <em>ar</em>.</p>
<p>Nesse tipo de linking, não há dependências de runtime, pois o executável gerado já irá conter todo o código necessário para execução.</p>
<h4 id="elf">ELF</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável ELF usando <em>static linking</em>.</p>
<p><img src="img/0a072b93add655e7e5e3ff13bac4a46b.png" alt="0a072b93add655e7e5e3ff13bac4a46b.png"></p>
<p>Primeiramente iremos gerar os arquivos-objeto dos dois arquivos principais, <em>main.c</em> e <em>mymath.c</em>:</p>
<blockquote>
<p><code>gcc -c main.c mymath.c</code></p>
</blockquote>
<p><img src="img/c8ac9cd7bd3491eb47571e7618d3e5ec.png" alt="c8ac9cd7bd3491eb47571e7618d3e5ec.png"></p>
<p>Agora, temos que criar a biblioteca estática via software <em>ar</em>, o archiver do projeto GNU. Lembrando que a biblioteca estática nada mais é que um <em>archive</em> contendo uma série de arquivos-objeto que a implementam. Para fins de compilação via gcc, é recomendável que a biblioteca criada tenha o nome de <strong>libnomedabiblioteca.a</strong>. No nosso caso, <em>libmymath.a</em>.</p>
<blockquote>
<p><code>ar rcs libmymath.a mymath.o</code></p>
</blockquote>
<p><img src="img/3091abe2ead637432833880e4be8f18b.png" alt="3091abe2ead637432833880e4be8f18b.png"></p>
<p>Após a geração da biblioteca, só precisamos linkar o objeto <em>main.o</em> com a biblioteca e gerar o executável final. O parâmetro <em>-L</em> do gcc especifica uma localização adicional na qual deve ser pesquisada as bibliotecas não encontradas em caminhos-padrão do sistema. Nesse caso, adicionamos a localização do diretório atualmente aberto. Por fim, o parâmetro <em>-l</em> especifica uma biblioteca a ser linkada, no formato <em>libmymath.a</em> (quando especificado apenas como <em>-lnomedabiblioteca</em>, o gcc irá procurar pela bibliteca <em>libnomedabiblioteca.a</em>).</p>
<blockquote>
<p><code>gcc -o main main.o -L./ -lmymath</code> ou <code>gcc -o main main.o -L./ -l:libmymath.a</code></p>
</blockquote>
<p><img src="img/4f0f416aa1588c1ab3b03da6555390d9.png" alt="4f0f416aa1588c1ab3b03da6555390d9.png"></p>
<p>Podemos utilizar o software <em>ldd</em>, que checa por informações de bibliotecas dinâmicas em um binário e não encontramos o nome da libmymath:</p>
<p><img src="img/d1d6ad28a4c941fd01e50afe054bd775.png" alt="d1d6ad28a4c941fd01e50afe054bd775.png"></p>
<p>Isso demonstra que, pelo menos para essa biblioteca, o linking ocorrido foi do tipo estático. Há ainda bibliotecas dinâmicas pois utilizamos a biblioteca padrão <em>libc</em> para prover funções de I/O, com o <em>printf</em>. Em GNU/Linux é possível gerar um executável 100% linkado estaticamente devido ao número das syscalls não mudarem - toda função implementada em C passa necessariamente por uma ou mais syscalls. Dessa forma, a geração fica facilitada pois para o compilador é necessário apenas conhecer os números das syscalls e seus argumentos para gerar um binário estático.</p>
<p>Para gerar um binário 100% estático, basta adicionar <em>-static</em> na linha de geração do executável. Verificando com o <em>ldd</em>, é retornado que o binário não é dinâmico:</p>
<p><img src="img/fda2c0b2f06ec1cb61e25bebaf7ec193.png" alt="fda2c0b2f06ec1cb61e25bebaf7ec193.png"></p>
<h4 id="pe">PE</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável PE usando <em>static linking</em>.</p>
<p><img src="img/83c263d08d2b409e063908b1a3774f7d.png" alt="83c263d08d2b409e063908b1a3774f7d.png"></p>
<p>O processo é semelhante ao ELF, mas nesse caso utillizaremos o compilador de C/C++ da microsoft (<em>cl.exe</em>), disponível no <a href="https://visualstudio.microsoft.com/vs/community/">Visual Studio Community</a>, na opção de &ldquo;Desenvolvimento para desktop com C++ &quot; e acessível via &ldquo;Developer Powershell for VS 2022&rdquo;</p>
<p><img src="img/a93049b5d97da6955944b6374a9ec7ae.png" alt="a93049b5d97da6955944b6374a9ec7ae.png"></p>
<p>O passo-a-passo segue abaixo, com a compilação do <em>main.c</em> e <em>mymath.c</em> para arquivos-objeto (<em>.obj</em> no Windows):</p>
<blockquote>
<p><code>cl.exe /c main.c mymath.c</code></p>
</blockquote>
<p><img src="img/54b052380d95f45d30149a3cce50a2d5.png" alt="54b052380d95f45d30149a3cce50a2d5.png"></p>
<p>A geração da biblioteca estática é feita a partir da ferramenta <em>lib.exe</em>, indicando o arquivo-objeto criado. O nome da lib ficará como <em>mymath.lib</em>:</p>
<blockquote>
<p><code>lib.exe .\mymath.obj</code></p>
</blockquote>
<p><img src="img/da51fe122d5d5265e27e0bf22d7e4197.png" alt="da51fe122d5d5265e27e0bf22d7e4197.png"></p>
<p>Por fim, chamaremos a ferramenta <em>link.exe</em>, o linker do Visual Studio, para gerar o executável final:</p>
<blockquote>
<p><code>link.exe main.obj mymath.lib</code></p>
</blockquote>
<p><img src="img/c7ca0764a57b49ea89ffb2be033d3ede.png" alt="c7ca0764a57b49ea89ffb2be033d3ede.png"></p>
<p>Verificando a Import Table do EXE com o software <a href="https://github.com/horsicq/Detect-It-Easy">Detect It Easy</a>, é possível perceber que não há dependências com relação ao código implementado.</p>
<p><img src="img/dcde4feb84220852205be7c6e2f5c13e.png" alt="dcde4feb84220852205be7c6e2f5c13e.png"></p>
<p>Note que há a dependência ainda da <em>KERNEL32.DLL</em>. Isso se deve ao fato de que no Windows as syscalls não são chamadas diretamente: os códigos deverão executar funções da <em>ntdll.dll</em> que irão chamar as syscalls. <em>Kernel32.dll</em> é uma biblioteca &ldquo;mais alto nível&rdquo; que a <em>ntdll.dll</em>, mais estável e documentada, e que chama a <em>ntdll.dll</em> para executar suas próprias funções.</p>
<p>Esse design dos componentes permite que o sistema operacional mude o número das syscalls sem impactar os softwares, e o número das syscalls pode mudar em uma atualização do Windows. Logo, o compilador não irá saber os números das syscalls a serem chamadas, necessitando chamar a <em>Kernel32.dll</em> (nesse caso) como API para suprir essa falta de número das syscalls. É por isso que comumente não encontramos binários estáticos para Windows, pois o número das syscalls pode mudar a qualquer momento, não sendo confiável para um compilador utilizá-las.</p>
<h3 id="dynamic-linking-load-time-dynamic-linking">Dynamic Linking (load-time Dynamic Linking)</h3>
<p>O linking estático permite rodar um código sem dependências, porém seu uso traz algumas desvantagens:</p>
<ul>
<li>O executável final irá conter o código da biblioteca, acarretando em um tamanho maior do código;</li>
<li>Quando houver uma atualização na biblioteca, será necessário recompilar também o código do executável final.</li>
</ul>
<p>A solução para esses problemas é adicionar uma dependência de runtime, uma biblioteca dinâmica. Seu código não irá compor o executável final, mas irá ter uma referência nas <em>Import Tables</em> dos arquivos PE (e sua contraparte ELF, a seção <em>.dynsym</em>).</p>
<p>A fase de linking também será diferente, pois não haverá a cópia do código para o executável, mas irão ser criados JMPs para seções especiais, como a <em>.plt</em> e a Global Offset Table (GOT) nos executáveis ELF. Qualquer chamada a código externo irá resultar em um JMP para seção <em>.plt</em>, que irá chamar um stub de código especial que irá recuperar o endereço da função externa na GOT.</p>
<p>Para executar o código final será necessário que a biblioteca esteja em um local padrão procurado pelo sistema operacional, ou adicionado via variáveis de ambiente, como veremos nas próximas seções.</p>
<h4 id="elf-1">ELF</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável ELF usando <em>dynamic linking</em>.</p>
<p><img src="img/1eb8a6ff3c59c68da7b01adaa76c3b08.png" alt="1eb8a6ff3c59c68da7b01adaa76c3b08.png"></p>
<p>O passo-a-passo para compilar uma solução com <em>dynamic linking</em> está descrito abaixo:</p>
<ol>
<li>compilação de <em>main.c</em> para arquivo objeto (<code>gcc -c main.c</code>);</li>
<li>compilação da <em>mymath.c</em> na biblioteca dinâmica <em>libmymath.so</em>. Esse processo necessita dos parâmetros <em>-fPIC</em> e <em>-shared</em> para permitir que o binário resultante tenha <em>Position Independent Code</em>, que permite um binário ser carregado em qualquer endereço na memória (e não só aquele definido no processo de compilação), e que esse binário é um objeto compartilhado (shared object);</li>
</ol>
<p>Após esses dois passos, exemplificados na imagem abaixo, podemos checar com o comando <em>file</em> que realmente a biblioteca gerada é um <em>shared object</em>, e não mais um simples arquivo composto de arquivos-objeto.</p>
<p><img src="img/77b3e851c98e4a11fe9ac552a4ea2516.png" alt="77b3e851c98e4a11fe9ac552a4ea2516.png"></p>
<p>O executável deve ser criado utilizando a opção <em>-L</em>, especificando o diretório atual (<em>./</em>). Isso faz com que o linker procure por bibliotecas também no diretório especificado. Essa opção, em conjunto com <em>-lmymath</em>, faz com que o linker procure e encontre o arquivo <em>libmymath.so</em>, realizando o linking dinâmico. O linking dinâmico pode ser evidenciado a partir da ferramenta <em>ldd</em>, que lista as bibliotecas dinâmicas utilizadas por um binário não estático:</p>
<p><img src="img/d55aeaf58bd50dde34f6f3f582794783.png" alt="d55aeaf58bd50dde34f6f3f582794783.png"></p>
<p>Note, porém, que o sotware não encontrou a biblioteca especificadada. A tentativa de execução pelo meio convencional também irá resultar em falha, conforme imagem abaixo. Isso se deve ao fato de que o loader procura por bibliotecas dinâmicas em locais padrão do sistema operacional.</p>
<p><img src="img/2041e21596ded757db806fc84f3767aa.png" alt="2041e21596ded757db806fc84f3767aa.png"></p>
<p>Para especificar um diretório não padrão, podemos utilizar a variável de ambiente <em>LD_LIBRARY_PATH</em>, passando um ponto para especificar o diretório padrão. Conforme imagem abaixo, é possível verificar que tanto o ldd quanto a execução do binário funcionam corretamente após a definição dessa variável:</p>
<p><img src="img/3428ff172fa38c2488cbf0bf382c0e83.png" alt="3428ff172fa38c2488cbf0bf382c0e83.png"></p>
<h4 id="pe-1">PE</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável PE usando <em>dynamic linking</em>.</p>
<p><img src="img/29604c65d3b9a736cc49ff67c88afb23.png" alt="29604c65d3b9a736cc49ff67c88afb23.png"></p>
<p>Para esse exemplo, utilizaremos o seguinte conteúdo para o arquivo <em>mymath.c</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;mymath.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="nf">soma</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>e para o arquivo <em>mymath.h</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">__declspec</span><span class="p">(</span><span class="n">dllexport</span><span class="p">)</span> <span class="nf">soma</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>
</span></span></code></pre></div><p>Isso é necessário para declarar a função <em>soma(int, int)</em> como um export da biblioteca dinâmica gerada, e, logo, acessível externamente.</p>
<p>O primeiro passo, como em outros anteriores, é a construção dos arquivos-objeto. Nesse caso, utilizaremos o <em>cl.exe /c main.c mymath.c</em> para gerá-los de uma só vez. Isso irá criar os arquivos de nome <em>main.obj</em> e <em>mymath.obj</em>:</p>
<p><img src="img/e4628cded96d729c7454cc5dbd3e4587.png" alt="e4628cded96d729c7454cc5dbd3e4587.png"></p>
<p>Para criar uma biblioteca dinâmica, ou DLL, no Windows, podemos utilizar a ferramenta <em>link.exe</em> com a linha de comando <em>link.exe /DLL mymath.obj</em>. Isso irá criar 3 arquivos: <em>mymath.dll</em>, <em>mymath.lib</em> e <em>mymath.exp</em>. Para nosso artigo, iremos focar em <em>mymath.dll</em> e <em>mymath.lib</em>.</p>
<p><img src="img/83d9918b8a8030626e2eadc70ac9e202.png" alt="83d9918b8a8030626e2eadc70ac9e202.png"></p>
<p>O linking dinâmico no Windows é um pouco diferente da sua contraparte Linux. Iremos utilizar a ferramenta <em>link.exe</em> para linkar o <em>main.obj</em> com a <em>mymath.lib</em>, através da linha de comando <em>link.exe main.obj mymath.lib</em>. Isso pode soar como um linking estático, mas não é! Esse arquivo <em>.lib</em> irá conter as informações necessárias para se linkar um código dinamicamente com <em>mymath.dll</em>, e esta, por sua vez, irá compor a dependência em runtime do binário. Em resumo: para compilar, devemos utilizar a <em>mymath.lib</em> e para rodar precisaremos da <em>mymath.dll</em> em um dos <a href="https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order">diretórios padrão para busca de DLLs</a>.</p>
<p>Como a DLL Search Order tem como um dos seus diretórios de busca o diretório corrente ou do binário, a execução não necessitará de nada além da <em>mymath.dll</em> para funcionar:</p>
<p><img src="img/3f5e7f5bee81850b08e3cf60fe5c659c.png" alt="3f5e7f5bee81850b08e3cf60fe5c659c.png"></p>
<p>Utilizando o sotware Detect It Easy, é possível verificar que há uma entrada na Import Table do executável que representa a função externa utilizada e a DLL. Isso caracteriza o linking dinâmico.</p>
<p><img src="img/853a8a6e530d18f7afa6ca46a55760b4.png" alt="853a8a6e530d18f7afa6ca46a55760b4.png"></p>
<h3 id="runtime-linking-run-time-dynamic-linking">Runtime Linking (run-time Dynamic Linking)</h3>
<p>O runtime dynamic linking envolve o uso de uma biblioteca dinâmica mas não gera uma entrada na <em>Import Table</em> ou <em>.dynsym</em>. Isso é possível pois a biblioteca dinâmica, diferentemente do dynamic linking tradicional, é linkada em tempo de runtime e não de compilação. São utilizadas funções especiais para recuperar os endereços das subrotinas requeridas e ponteiros para funções são instanciados para executá-las. Como a forma de obter essas informações em runtime dependem do formato de arquivo e até de componentes do sistema operacional, geralmente são escritos códigos diferentes para sistemas operacionais diferentes.</p>
<h4 id="elf-2">ELF</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável ELF usando <em>runtime linking</em>.</p>
<p><img src="img/1db0c4cacbe404da15203596254e1f45.png" alt="1db0c4cacbe404da15203596254e1f45.png"></p>
<p>Abaixo está o código <em>main.c</em> utilizado para o runtime linking.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define _GNU_SOURCE
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">soma_func</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">void</span> <span class="o">*</span> <span class="n">mymath_handle</span> <span class="o">=</span> <span class="nf">dlopen</span><span class="p">(</span><span class="s">&#34;libmymath.so&#34;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span> <span class="o">|</span> <span class="n">RTLD_GLOBAL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">mymath_handle</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ERROR: dlopen!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;libmymath.so loaded!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">soma_func</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">soma_func</span><span class="p">)</span> <span class="nf">dlsym</span><span class="p">(</span><span class="n">mymath_handle</span><span class="p">,</span> <span class="s">&#34;soma&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ERROR: dlsym!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;soma() found!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="nf">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;The sum is: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">if</span><span class="p">(</span><span class="nf">dlclose</span><span class="p">(</span><span class="n">mymath_handle</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ERROR: dlclose!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;libmymath.so handle closed!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Podemos copiar a <em>libmath.so</em> gerada no dynamic linking para o diretório de exemplo do runtime linking para não termos que recompilá-la. Para compilar o novo arquivo <em>main.c</em>, devemos passar para o gcc a biblioteca de linking dinâmico, que contém as funções necessárias para realizar a pesquisa e recuperação dos endereços dos símbolos disponíveis na biblioteca de exemplo.</p>
<blockquote>
<p><code>gcc -o main main.c -ldl</code></p>
</blockquote>
<p>Conforme exemplificado na imagem a seguir, o binário foi gerado com sucesso mas sua execução por si só resulta em erro. Esse é o mesmo caso que explicamos no dynamic linking, resolvido com o uso da variável de ambiente <em>LD_LIBRARY_PATH</em>.</p>
<p><img src="img/ef081ba00b3556c5163f26e8062fa253.png" alt="ef081ba00b3556c5163f26e8062fa253.png"></p>
<p>Seguindo o fluxo de código, o código da biblioteca <em>libmymath.so</em> é carregado através das funções <em>dlopen</em> e <em>dlsym</em>, para encontrar em memória o endereço da função <em>soma(int, int)</em>. Quando encontrado, é instanciado um ponteiro para a função que logo após é chamado, retornando o valor 3. Por fim, a biblioteca é fechada e o código termina.</p>
<p><img src="img/85bfcd604d7fd080feac9e959df71952.png" alt="85bfcd604d7fd080feac9e959df71952.png"></p>
<p>Logo, esse binário necessita que <em>libmymath.so</em> exista para que sua execução tenha sucesso. Porém, se checarmos a saída do software <em>ldd</em> para esse binário, verificaremos que não há nenhuma entrada para o arquivo <em>libmymath.so</em>. Isso caracteriza runtime linking.</p>
<p><img src="img/2bc1b3980eb3d44e13a663e41a7186c5.png" alt="2bc1b3980eb3d44e13a663e41a7186c5.png"></p>
<h4 id="pe-2">PE</h4>
<p>No diagrama abaixo estão representados os passos para a construção de um executável PE usando <em>runtime linking</em>.</p>
<p><img src="img/fb6b46ec034c98dbcaa74e3a4a3d66bc.png" alt="fb6b46ec034c98dbcaa74e3a4a3d66bc.png"></p>
<p>Neste exemplo, iremos utilizar o seguinte conteúdo no arquivo <em>main.c</em>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">HMODULE</span> <span class="n">mymathDll</span> <span class="o">=</span> <span class="nf">LoadLibraryA</span><span class="p">(</span><span class="s">&#34;mymath.dll&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mymathDll</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ERROR: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">func</span> <span class="n">somaPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="nf">GetProcAddress</span><span class="p">(</span><span class="n">mymathDll</span><span class="p">,</span> <span class="s">&#34;soma&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">somaPtr</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;ERROR: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">GetLastError</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;A soma eh %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="nf">somaPtr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>No caso de um EXE, para realizar runtime linking é necessário o uso de APIs como <em>LoadLibrary/GetProcAddress/GetModuleHandle</em> para carregar uma DLL em um ponto do código e encontrar a função que se deseja executar.</p>
<p>Para esse exemplo, podemos copiar a DLL <em>mymath.dll</em> já compilada na seção de dynamic linking para o diretório que <em>main.c</em> está. Iremos gerar o executável <em>main.exe</em> através da execução da linha de comando <em>cl.exe main.c</em>. Sua execução, caso mymath.dll esteja no mesmo diretório, não resulta em nenhum problema.</p>
<p><img src="img/9430a4e1ccfb359bcf8d1f50cedbb0f3.png" alt="9430a4e1ccfb359bcf8d1f50cedbb0f3.png"></p>
<p>Na ferramenta DIE é possível verificar que não há entradas para a mymath.dll, caracterizando runtime linking.</p>
<p><img src="img/d2c1e671f63d7886c097cf29e351ab79.png" alt="d2c1e671f63d7886c097cf29e351ab79.png"></p>
<h1 id="conclusão">Conclusão</h1>
<p>Nesse artigo foram abordados os tipos de linking existentes nos principais sistemas operacionais e formatos. No próximo artigo dessa série iremos explorar as possibilidades de transformar esses tipos de linking em capacidades maliciosas (em especial, o runtime linking!).</p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a href="https://blog.midnighthackings.com/posts/crackme-0x01/"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a href="https://blog.midnighthackings.com/posts/hello-world-arm-pt1/"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
          <div class="footer-mail">
          <i class="far fa-envelope"></i> <a href="mailto:midnight.reverser@outlook.com">midnight.reverser@outlook.com</a> </div>
      
      
  </div>


<p class="copyright meta">GPL is life, contribute to copyleft projects!</p>

</div>
</footer></main>
    </body>
    <script src=https://blog.midnighthackings.com/js/navbutton.js></script>
</html>
